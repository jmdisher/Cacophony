package com.jeffdisher.cacophony.commands;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintStream;
import java.nio.file.Files;

import com.eclipsesource.json.JsonArray;
import com.eclipsesource.json.JsonObject;
import com.jeffdisher.cacophony.Version;
import com.jeffdisher.cacophony.data.global.GlobalData;
import com.jeffdisher.cacophony.data.global.description.StreamDescription;
import com.jeffdisher.cacophony.data.global.index.StreamIndex;
import com.jeffdisher.cacophony.data.global.recommendations.StreamRecommendations;
import com.jeffdisher.cacophony.data.global.record.DataElement;
import com.jeffdisher.cacophony.data.global.record.ElementSpecialType;
import com.jeffdisher.cacophony.data.global.record.StreamRecord;
import com.jeffdisher.cacophony.data.global.records.StreamRecords;
import com.jeffdisher.cacophony.data.local.FollowIndex;
import com.jeffdisher.cacophony.data.local.FollowRecord;
import com.jeffdisher.cacophony.data.local.GlobalPrefs;
import com.jeffdisher.cacophony.data.local.LocalIndex;
import com.jeffdisher.cacophony.logic.Executor;
import com.jeffdisher.cacophony.logic.ILocalActions;
import com.jeffdisher.cacophony.logic.LoadChecker;
import com.jeffdisher.cacophony.logic.RemoteActions;
import com.jeffdisher.cacophony.types.CacophonyException;
import com.jeffdisher.cacophony.types.IpfsFile;
import com.jeffdisher.cacophony.types.IpfsKey;
import com.jeffdisher.cacophony.types.UsageException;
import com.jeffdisher.cacophony.utils.Assert;


/**
 * Walks the existing data in the local cache, creating and populating the existing directory with a static site
 * including all of this information.
 * This is a simple way to view everything prior to the dynamic content in the WebUI which will be added in version 2.0.
 */
public record HtmlOutputCommand(File _directory) implements ICommand
{
	@Override
	public void scheduleActions(Executor executor, ILocalActions local) throws IOException, CacophonyException
	{
		if (_directory.exists())
		{
			throw new UsageException("Directory already exists: " + _directory);
		}
		if (!_directory.mkdir())
		{
			throw new UsageException("Directory cannot be created: " + _directory);
		}
		
		// We need the local index.
		LocalIndex localIndex = local.readIndex();
		if (null == localIndex)
		{
			throw new UsageException("Channel must be created before generating HTML output");
		}
		
		// Write the static files in the directory.
		_writeStaticFile(_directory, "index.html");
		_writeStaticFile(_directory, "prefs.html");
		_writeStaticFile(_directory, "utils.js");
		_writeStaticFile(_directory, "user.html");
		_writeStaticFile(_directory, "play.html");
		_writeStaticFile(_directory, "recommending.html");
		_writeStaticFile(_directory, "following.html");
		
		// Now, write the generated_db.js.
		RemoteActions remote = RemoteActions.loadIpfsConfig(executor, local);
		PrintStream generatedStream = new PrintStream(new FileOutputStream(new File(_directory, "generated_db.js")));
		generatedStream.println("// Note that this file is generated by HtmlOutputCommand.");
		generatedStream.println();
		
		// DATA_common.
		JsonObject dataCommon = new JsonObject();
		IpfsKey ourPublicKey = remote.getPublicKey();
		dataCommon.set("publicKey", ourPublicKey.toPublicKey());
		generatedStream.println("var DATA_common = " + dataCommon.toString());
		generatedStream.println();
		
		// DATA_version.
		JsonObject dataVersion = new JsonObject();
		dataVersion.set("hash", Version.HASH);
		dataVersion.set("version", Version.TAG);
		generatedStream.println("var DATA_version = " + dataVersion.toString());
		generatedStream.println();
		
		// DATA_prefs.
		GlobalPrefs prefs = local.readPrefs();
		JsonObject dataPrefs = new JsonObject();
		dataPrefs.set("edgeSize", prefs.videoEdgePixelMax());
		dataPrefs.set("followerCacheBytes", prefs.followCacheTargetBytes());
		generatedStream.println("var DATA_prefs = " + dataPrefs.toString());
		generatedStream.println();
		
		// DATA_userInfo.
		JsonObject dataUserInfo = new JsonObject();
		// We need to make this information from ourselves and everyone we are following.
		LoadChecker checker = new LoadChecker(remote, local);
		_populateDataForUserRoot(checker, dataUserInfo, ourPublicKey, localIndex.lastPublishedIndex());
		FollowIndex followIndex = local.loadFollowIndex();
		for(FollowRecord record : followIndex)
		{
			_populateDataForUserRoot(checker, dataUserInfo, record.publicKey(), record.lastFetchedRoot());
		}
		generatedStream.println("var DATA_userInfo = " + dataUserInfo.toString());
		generatedStream.println();
		
		// DATA_elements.
		JsonObject dataElements = new JsonObject();
		// We want to output for every element for our own channel and every entry in every followed user.
		// TODO:  Fix how we describe non-cached elements in the front-end and here.
		_populateAllElementsFromUserRoot(checker, dataElements, localIndex.lastPublishedIndex());
		for(FollowRecord record : followIndex)
		{
			_populateAllElementsFromUserRoot(checker, dataElements, record.lastFetchedRoot());
		}
		generatedStream.println("var DATA_elements = " + dataElements.toString());
		generatedStream.println();
		
		// DATA_userPosts.
		JsonObject dataUserPosts = new JsonObject();
		_populatePostsForUser(checker, dataUserPosts, ourPublicKey, localIndex.lastPublishedIndex());
		for(FollowRecord record : followIndex)
		{
			_populatePostsForUser(checker, dataUserPosts, record.publicKey(), record.lastFetchedRoot());
		}
		generatedStream.println("var DATA_userPosts = " + dataUserPosts.toString());
		generatedStream.println();
		
		// DATA_recommended.
		JsonObject dataRecommended = new JsonObject();
		_populateRecommendationsForUser(checker, dataRecommended, ourPublicKey, localIndex.lastPublishedIndex());
		for(FollowRecord record : followIndex)
		{
			_populateRecommendationsForUser(checker, dataElements, record.publicKey(), record.lastFetchedRoot());
		}
		generatedStream.println("var DATA_recommended = " + dataRecommended.toString());
		generatedStream.println();
		
		// DATA_following.
		JsonArray dataFollowing = new JsonArray();
		for(FollowRecord record : followIndex)
		{
			dataFollowing.add(record.publicKey().toPublicKey());
		}
		generatedStream.println("var DATA_following = " + dataFollowing.toString());
		generatedStream.println();
	}


	private void _writeStaticFile(File directory, String fileName) throws IOException
	{
		String path = "/resources/site/" + fileName;
		InputStream stream = HtmlOutputCommand.class.getResourceAsStream(path);
		Files.copy(stream, new File(directory, fileName).toPath());
		stream.close();
	}

	private static void _populateDataForUserRoot(LoadChecker checker, JsonObject rootData, IpfsKey publicKey, IpfsFile indexRoot) throws IOException
	{
		StreamIndex index = GlobalData.deserializeIndex(checker.loadCached(indexRoot));
		byte[] rawDescription = checker.loadCached(IpfsFile.fromIpfsCid(index.getDescription()));
		StreamDescription description = GlobalData.deserializeDescription(rawDescription);
		JsonObject thisUser = new JsonObject();
		thisUser.set("name", description.getName());
		thisUser.set("description", description.getDescription());
		thisUser.set("userPicUrl", checker.getCachedUrl(IpfsFile.fromIpfsCid(description.getPicture())).toString());
		rootData.set(publicKey.toPublicKey(), thisUser);
	}

	private static void _populateAllElementsFromUserRoot(LoadChecker checker, JsonObject rootData, IpfsFile indexRoot) throws IOException
	{
		StreamIndex index = GlobalData.deserializeIndex(checker.loadCached(indexRoot));
		byte[] rawRecords = checker.loadCached(IpfsFile.fromIpfsCid(index.getRecords()));
		StreamRecords records = GlobalData.deserializeRecords(rawRecords);
		for (String rawCid : records.getRecord())
		{
			IpfsFile cid = IpfsFile.fromIpfsCid(rawCid);
			byte[] rawRecord = checker.loadCached(cid);
			StreamRecord record = GlobalData.deserializeRecord(rawRecord);
			JsonObject thisElt = new JsonObject();
			thisElt.set("name", record.getName());
			// TODO:  Add the description once it is added to the StreamRecord type.
			thisElt.set("description", "");
			thisElt.set("publishedSecondsUtc", record.getPublishedSecondsUtc());
			// We want to find the thumbnail and video.
			for (DataElement leaf : record.getElements().getElement())
			{
				IpfsFile leafCid = IpfsFile.fromIpfsCid(leaf.getCid());
				if (ElementSpecialType.IMAGE == leaf.getSpecial())
				{
					// Thumbnail - these may be cached or not.
					if (checker.isCached(leafCid))
					{
						thisElt.set("thumbnailUrl", checker.getCachedUrl(leafCid).toString());
					}
				}
				else if (null != leaf.getSpecial())
				{
					// Unknown type.
					Assert.assertTrue(false);
				}
				else
				{
					// We will return the last video we find, so check the codec - these may be cached or not.
					if (leaf.getMime().startsWith("video/") && checker.isCached(leafCid))
					{
						thisElt.set("videoUrl", checker.getCachedUrl(leafCid).toString());
					}
				}
			}
			rootData.set(cid.toSafeString(), thisElt);
		}
	}

	private static void _populatePostsForUser(LoadChecker checker, JsonObject rootData, IpfsKey publicKey, IpfsFile indexRoot) throws IOException
	{
		StreamIndex index = GlobalData.deserializeIndex(checker.loadCached(indexRoot));
		byte[] rawRecords = checker.loadCached(IpfsFile.fromIpfsCid(index.getRecords()));
		StreamRecords records = GlobalData.deserializeRecords(rawRecords);
		JsonArray array = new JsonArray();
		for (String rawCid : records.getRecord())
		{
			array.add(rawCid);
		}
		rootData.set(publicKey.toPublicKey(), array);
	}

	private static void _populateRecommendationsForUser(LoadChecker checker, JsonObject rootData, IpfsKey publicKey, IpfsFile indexRoot) throws IOException
	{
		StreamIndex index = GlobalData.deserializeIndex(checker.loadCached(indexRoot));
		byte[] rawRecommendations = checker.loadCached(IpfsFile.fromIpfsCid(index.getRecommendations()));
		StreamRecommendations recommendations = GlobalData.deserializeRecommendations(rawRecommendations);
		JsonArray array = new JsonArray();
		for (String rawCid : recommendations.getUser())
		{
			array.add(rawCid);
		}
		rootData.set(publicKey.toPublicKey(), array);
	}
}
