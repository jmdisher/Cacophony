<!DOCTYPE html>
<html lang="en" ng-app="App">
<head>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js" type="text/javascript"></script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.3.3/angular.min.js" type="text/javascript"></script>

<meta charset="utf-8"></meta>
<meta name="viewport" content="width=device-width, initial-scale=1"></meta>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-gH2yIJqKdNHPEq0n4Mqa/HGKIhSkIHeL5AyhkYV8i59U5AR6csBvApHHNl/vI1Bx" crossorigin="anonymous"></link>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/js/bootstrap.bundle.min.js" integrity="sha384-A3rJD856KowSb7dwlZdYEkO39Gagi7vIsF0jrRAoQmDKKtQBHUuLZ9AsSv4jD4Xa" crossorigin="anonymous"></script>

<script src="./utils.js" type="text/javascript"></script>
<script src="./rest.js" type="text/javascript"></script>
<script src="./event_api.js" type="text/javascript"></script>
<script src="./bindings.js" type="text/javascript"></script>
<script type="text/javascript">
function startCamera(height, width, fps)
{
	return new Promise((resolve, reject) => {
		let video = { width: {exact: width}, height: {exact: height}};
		if (null !== fps)
		{
			video.frameRate = {exact: fps};
		}
		let constraints = { video: video, audio: {channelCount: {exact: 1}}};
		navigator.mediaDevices.getUserMedia(constraints).then(resolve, reject);
	});
}

function stopCamera(previewElement, videoState, audioState)
{
	previewElement.srcObject = null;
	videoState.stream.getTracks().forEach(function(track) { track.stop(); });
	videoState.stream = null;
	audioState.stream = null;
}

function openVideoUploadWebSocket(draftId, height, width, videoType, onOpen, onClose)
{
	let ws = new WebSocket("ws://127.0.0.1:8000/draft/originalVideo/upload/" + draftId + "/" + height + "/" + width + "/" + videoType, "video");
	ws.onopen = onOpen;
	ws.onclose = onClose;
	ws.onerror = function(event)
	{
		console.log(event);
	};
	
	return ws;
}

function openAudioUploadWebSocket(draftId, audioType, onOpen, onClose)
{
	let ws = new WebSocket("ws://127.0.0.1:8000/draft/audio/upload/" + draftId + "/" + audioType, "audio");
	ws.onopen = onOpen;
	ws.onclose = onClose;
	ws.onerror = function(event)
	{
		console.log(event);
	};
	
	return ws;
}

function uploadVideoData(draftId, height, width, videoType, fileData, progressCallback, finalSizeCallback)
{
	let bytes = 0;
	let ws = openVideoUploadWebSocket(draftId, height, width, videoType,
	function()
	{
		let chunkSize = 64 * 1024;
		for (let start = 0; start < fileData.size; start += chunkSize)
		{
			let split = Math.min(fileData.size - start, chunkSize);
			let blob = fileData.slice(start, start + split);
			ws.send(blob);
			bytes += split;
			progressCallback(bytes, fileData.size);
		}
		ws.close();
	},
	function()
	{
		finalSizeCallback(bytes);
	});
}

function uploadAudioData(draftId, audioType, fileData, progressCallback, finalSizeCallback)
{
	let bytes = 0;
	let ws = openAudioUploadWebSocket(draftId, audioType,
	function()
	{
		let chunkSize = 64 * 1024;
		for (let start = 0; start < fileData.size; start += chunkSize)
		{
			let split = Math.min(fileData.size - start, chunkSize);
			let blob = fileData.slice(start, start + split);
			ws.send(blob);
			bytes += split;
			progressCallback(bytes, fileData.size);
		}
		ws.close();
	},
	function()
	{
		finalSizeCallback(bytes);
	});
}

function startRecordingVideo(stream, videoBitrate, audioBitrate, draftId, height, width, finalSizeCallback)
{
	let recorder = new MediaRecorder(stream, { mimeType: 'video/webm', audioBitsPerSecond: audioBitrate,  videoBitsPerSecond: videoBitrate });
	let bytes = 0;
	let ws = openVideoUploadWebSocket(draftId, height, width, 'webm',
	function()
	{
		recorder.addEventListener('dataavailable', function(e) {
			bytes += e.data.size;
			ws.send(e.data);
		});
		recorder.addEventListener('stop', function() {
			ws.close();
		});
		recorder.start(100);
	},
	function()
	{
		finalSizeCallback(bytes);
	});
	return recorder;
}

function stopRecordingVideo(videoState)
{
	videoState.recorder.stop();
	videoState.recorder = null;
}

function startRecordingAudioOnly(stream, audioBitrate, draftId, finalSizeCallback)
{
	let recorder = new MediaRecorder(stream, { mimeType: 'audio/ogg', audioBitsPerSecond: audioBitrate });
	let bytes = 0;
	let ws = openAudioUploadWebSocket(draftId, 'ogg',
	function()
	{
		recorder.addEventListener('dataavailable', function(e) {
			bytes += e.data.size;
			ws.send(e.data);
		});
		recorder.addEventListener('stop', function() {
			ws.close();
		});
		recorder.start(100);
	},
	function()
	{
		finalSizeCallback(bytes);
	});
	return recorder;
}

function stopRecordingAudio(audioState)
{
	audioState.recorder.stop();
	audioState.recorder = null;
}

function setThumbnail(canvas, draft)
{
	let image = new Image();
	canvas.width = draft.thumbnail.width;
	canvas.height = draft.thumbnail.height;
	image.onload = function () {
		canvas.getContext('2d').drawImage(image, 0, 0);
	};
	image.src = "http://127.0.0.1:8000/draft/thumb/" + draft.id + "?uniq=" + (new Date()).getTime();
}

function selectDraft(canvas, original_review, processed_review, audio_review, scope, draft)
{
	scope.selectedDraft = draft;
	if (null !== draft)
	{
		if (null !== draft.thumbnail)
		{
			setThumbnail(canvas, draft);
		}
		else
		{
			canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);
		}
		if (null !== draft.originalVideo)
		{
			scope.videoConfig.height = draft.originalVideo.height;
			scope.videoConfig.width = draft.originalVideo.width;
			original_review.src = "http://127.0.0.1:8000/draft/originalVideo/" + draft.id + "?uniq=" + (new Date()).getTime();
		}
		else
		{
			original_review.src = "";
		}
		
		if (null !== draft.processedVideo)
		{
			processed_review.src = "http://127.0.0.1:8000/draft/processedVideo/" + draft.id + "?uniq=" + (new Date()).getTime();
		}
		else
		{
			processed_review.src = "";
		}
		if (null !== draft.audio)
		{
			audio_review.src = "http://127.0.0.1:8000/draft/audio/" + draft.id + "?uniq=" + (new Date()).getTime();
		}
		else
		{
			audio_review.src = "";
		}
		populateSyntheticType(scope.selectedDraft);
	}
	else
	{
		original_review.src = "";
		processed_review.src = "";
		audio_review.src = "";
	}
}

function postUpdatedThumbnail(canvas, captureVideo, selectedDraft, width, height)
{
	canvas.width = width;
	canvas.height = height;
	return new Promise((resolve, reject) => {
		canvas.getContext('2d').drawImage(captureVideo, 0, 0, width, height);
		canvas.toBlob((blob) => {
			REST.POST_withBinary("/draft/thumb/" + selectedDraft.id + "/" + height + "/" + width + "/jpeg", blob)
				.then((response) => {
					selectedDraft.thumbnail = {
						height: height,
						width: width,
						byteSize: blob.size,
					};
					setThumbnail(canvas, selectedDraft);
					resolve();
				});
		}, "image/jpeg");
	});
}

function saveDraft(selectedDraft)
{
	let variables = {
		"NAME": selectedDraft.title,
		"DESCRIPTION": selectedDraft.description,
		"DISCUSSION_URL": selectedDraft.discussionUrl,
	};
	return REST.POST_asForm("/draft/" + selectedDraft.id, variables);
}

// The "type" field is essentially a synthetic enum (see POST_Raw_DraftPublish.PublishType):
// -VIDEO
// -TEXT_ONLY
// -AUDIO
// This method over-writes that field in the given draft by looking at the other elements to see what kind of data is present.
// This can be later over-written again since it is isn't actually part of the data model but just meant to be a convenient way of communicating what parts of the UI the user wants to see and what data it should actually publish.
function populateSyntheticType(draft)
{
	// If we have a processed video OR an original video, this can be considered a VIDEO type.
	// If there is no video, check audio.
	// Otherwise, we default to TEXT_ONLY.
	// Note that any type can have a thumbnail image.
	let type = "TEXT_ONLY";
	if ((null !== draft.originalVideo) || (null !== draft.processedVideo))
	{
		type = "VIDEO";
	}
	else if (null !== draft.audio)
	{
		type = "AUDIO";
	}
	draft.type = type;
}

function onProcessingSocketOpen(socket)
{
}

function onProcessingKeyCreate(videoState, key, value)
{
	// We will only bother with the final processed size, in this path (the input bytes will be zero on create).
	if (key === "outputBytes")
	{
		videoState.finalProcessed = value;
	}
}

function onProcessingKeyUpdate(selectedDraft, processing_progress_bar, key, value)
{
	// We only have an interest in the in-progress size, in this path (since output bytes is only ever sent in the create).
	if (key === "inputBytes")
	{
		let percentage = Math.round(100 * value / selectedDraft.originalVideo.byteSize);
		console.log("Processing " + percentage + "% " + value);
		processing_progress_bar.ariaValueNow = percentage;
		processing_progress_bar["style"] = "width: " + percentage + "%;";
		processing_progress_bar.textContent = percentage + "%";
	}
}

function onProcessingKeyDelete(key)
{
	// We don't need to track the deletion.
}

function onProcessingSocketClose(scope, processed_review, event, ignoreError)
{
	let isSuccess = (1000 === event.code);
	if (isSuccess)
	{
		scope.selectedDraft.processedVideo = {
			height: scope.videoConfig.height,
			width: scope.videoConfig.width,
			byteSize: scope.videoState.finalProcessed,
		};
		processed_review.src = "http://127.0.0.1:8000/draft/processedVideo/" + scope.selectedDraft.id + "?uniq=" + (new Date()).getTime();
	}
	scope.videoState.processingSocket = null;
	scope.videoState.finalProcessed = 0;
	scope.$apply();
	// We will allow errors, and just ignore them, in the case where this was invoked for an existing processing operation, since there might not be one.
	// Otherwise, we want to report that something odd happened.
	if (!isSuccess && !ignoreError)
	{
		alert(event.reason);
	}
}

// onLoaded(file, mime, tag_with_meta_data)
function loadMetaData(type, file, mime, onLoaded)
{
	const elt = document.createElement(type);
	elt.addEventListener('loadedmetadata', event => {
		onLoaded(file, mime, elt);
	})
	elt.src = URL.createObjectURL(file);
}

function createAndSelectNewDraft($scope, replyToCid)
{
	REST.POST("/allDrafts/new/" + replyToCid)
		.then(data => data.json())
		.then(draftObject => {
			populateSyntheticType(draftObject);
			$scope.drafts.push(draftObject);
			$scope.selectedDraft = draftObject;
			$scope.$apply();
		});
}


// GLOBAL_Application is defined in bindings.js.
GLOBAL_Application.controller('AppController', function($scope)
{
	let canvas = document.getElementById('canvas');
	let video_preview = document.getElementById('video_preview');
	let original_review = document.getElementById('original_review');
	let audio_review = document.getElementById('audio_review');
	let processed_review = document.getElementById('processed_review');
	let processing_progress_bar = document.getElementById('processing_progress_bar');
	let video_upload_progress_bar = document.getElementById('video_upload_progress_bar');
	let audio_upload_progress_bar = document.getElementById('audio_upload_progress_bar');
	
	$scope.drafts = null;
	$scope.selectedDraft = null;
	$scope.inProgress = false;
	
	// We populate the videoConfig with some basic defaults and then we will see if we can read and modify the processing command, later ("GET /server/processingCommand").
	$scope.videoConfig = {
		// We will default to 480p with 30 FPS since this configuration is commonly supported.
		height: 480,
		width: 640,
		fps: 30,
		// The browser tends to default to something like 2.5 Mbps for video and 128 kbps for audio but we will use a smaller number in case the user can't post-process (they can change this in the UI, themselves).
		videoBitrate: 256000,
		audioBitrate: 64000,
		// We will set this to non-null if it can be changed.
		mutableProcessingCommand: null,
	};
	$scope.videoState = {
		detecting: false,
		resolutions: null,
		stream: null,
		recorder: null,
		processingSocket: null,
		finalProcessed: 0,
	};
	$scope.audioState = {
		stream: null,
		recorder: null,
		processingSocket: null,
		finalProcessed: 0,
	};
	
	// Data we use to with the manual file uploads.
	$scope.selectedFiles = {
		uploadingVideo: false,
		uploadingAudio: false,
		uploadingThumbnail: false,
	};
	
	$scope.selectDraft = function(draft)
	{
		selectDraft(canvas, original_review, processed_review, audio_review, $scope, draft);
		// These keys are defined in VideoProcessContainer.java.
		$scope.videoState.processingSocket = EVENTS_API.existingVideo($scope.selectedDraft.id
			// onSocketOpen
			, onProcessingSocketOpen
			// onCreate
			, function(key, value, isNewest) { onProcessingKeyCreate($scope.videoState, key, value); }
			// onUpdate
			, function(key, value) {onProcessingKeyUpdate($scope.selectedDraft, processing_progress_bar, key, value); }
			// onDelete
			, onProcessingKeyDelete
			// Special
			, function(string)
			{
				// Do nothing.
				console.log("Unhandled special: " + string);
			}
			// onSocketClose
			, function(event) { onProcessingSocketClose($scope, processed_review, event, true); }
		);
	}
	$scope.createNewDraft = function()
	{
		// We use "NONE" as the "replyTo" when creating a draft this way.
		createAndSelectNewDraft($scope, "NONE");
	}
	$scope.deleteDraft = function(draft)
	{
		REST.DELETE("/draft/" + draft.id)
			.then(data => {
				if ((null !== $scope.selectedDraft) && ($scope.selectedDraft.id === draft.id))
				{
					selectDraft(canvas, original_review, processed_review, audio_review, $scope, null);
				}
				$scope.drafts = $scope.drafts.filter((element, index, array) => {
					return (element.id !== draft.id);
				});
				$scope.$apply();
			});
	}
	$scope.startCamera = function()
	{
		startCamera($scope.videoConfig.height, $scope.videoConfig.width, $scope.videoConfig.fps)
			.then(result => {
				$scope.videoState.stream = result;
				// We will also extract the audio track.
				$scope.audioState.stream = new MediaStream(result.getAudioTracks());
				video_preview.srcObject = result;
				$scope.$apply();
			}, error => {
				alert(error);
				$scope.$apply();
			});
	}
	$scope.stopCamera = function()
	{
		stopCamera(video_preview, $scope.videoState, $scope.audioState);
	}
	$scope.startRecordingVideo = function()
	{
		$scope.videoState.recorder = startRecordingVideo($scope.videoState.stream
			, $scope.videoConfig.videoBitrate
			, $scope.videoConfig.audioBitrate
			, $scope.selectedDraft.id
			, $scope.videoConfig.height
			, $scope.videoConfig.width
			, function(finalByteSize)
			{
				$scope.selectedDraft.originalVideo = {
					height: $scope.videoConfig.height,
					width: $scope.videoConfig.width,
					byteSize: finalByteSize,
				};
				$scope.$apply();
				original_review.src = "http://127.0.0.1:8000/draft/originalVideo/" + $scope.selectedDraft.id + "?uniq=" + (new Date()).getTime();
			}
		);
	}
	$scope.stopRecordingVideo = function()
	{
		stopRecordingVideo($scope.videoState);
	}
	$scope.startRecordingAudioOnly = function()
	{
		$scope.audioState.recorder = startRecordingAudioOnly($scope.audioState.stream
			, $scope.videoConfig.audioBitrate
			, $scope.selectedDraft.id
			, function(finalByteSize)
			{
				$scope.selectedDraft.audio = {
					height: 0,
					width: 0,
					byteSize: finalByteSize,
				};
				$scope.$apply();
				audio_review.src = "http://127.0.0.1:8000/draft/audio/" + $scope.selectedDraft.id + "?uniq=" + (new Date()).getTime();
			}
		);
	}
	$scope.stopRecordingAudio = function()
	{
		stopRecordingAudio($scope.audioState);
	}
	$scope.startProcessing = function()
	{
		// The processing socket uses our standard events API.
		// These keys are defined in VideoProcessContainer.java.
		// (Note that the processing command may be null in the cases where the server was ignoring it, anyway).
		$scope.videoState.processingSocket = EVENTS_API.processVideo($scope.selectedDraft.id, $scope.videoConfig.mutableProcessingCommand
			// onSocketOpen
			, onProcessingSocketOpen
			// onCreate
			, function(key, value, isNewest) { onProcessingKeyCreate($scope.videoState, key, value); }
			// onUpdate
			, function(key, value) {onProcessingKeyUpdate($scope.selectedDraft, processing_progress_bar, key, value); }
			// onDelete
			, onProcessingKeyDelete
			// Special
			, function(string)
			{
				// Do nothing.
				console.log("Unhandled special: " + string);
			}
			// onSocketClose
			, function(event) { onProcessingSocketClose($scope, processed_review, event, false); }
		);
	}
	$scope.stopProcessing = function()
	{
		// Constant defined in VideoProcessContainer.java.
		$scope.videoState.processingSocket.send("COMMAND_CANCEL_PROCESSING");
	}
	$scope.captureFromPreview = function()
	{
		postUpdatedThumbnail(canvas, video_preview, $scope.selectedDraft, $scope.videoConfig.width, $scope.videoConfig.height)
			.then((response) => {
				$scope.$apply();
			});
	}
	$scope.captureOriginal = function()
	{
		postUpdatedThumbnail(canvas, original_review, $scope.selectedDraft, $scope.videoConfig.width, $scope.videoConfig.height)
			.then((response) => {
				$scope.$apply();
			});
	}
	$scope.captureProcessed = function()
	{
		postUpdatedThumbnail(canvas, processed_review, $scope.selectedDraft, $scope.videoConfig.width, $scope.videoConfig.height)
			.then((response) => {
				$scope.$apply();
			});
	}
	$scope.deleteOriginalVideo = function(draft)
	{
		$scope.inProgress = true;
		REST.DELETE("/draft/originalVideo/" + draft.id)
			.then(data => {
				draft.originalVideo = null;
				$scope.inProgress = false;
				$scope.$apply();
			});
	}
	$scope.deleteProcessedVideo = function(draft)
	{
		$scope.inProgress = true;
		REST.DELETE("/draft/processedVideo/" + draft.id)
			.then(data => {
				draft.processedVideo = null;
				$scope.inProgress = false;
				$scope.$apply();
			});
	}
	$scope.deleteAudio = function(draft)
	{
		$scope.inProgress = true;
		REST.DELETE("/draft/audio/" + draft.id)
			.then(data => {
				draft.audio = null;
				$scope.inProgress = false;
				$scope.$apply();
			});
	}
	$scope.deletethumbnail = function(draft)
	{
		$scope.inProgress = true;
		REST.DELETE("/draft/thumb/" + draft.id)
			.then(data => {
				// Update UI.
				canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);
				
				// Update data model.
				draft.thumbnail = null;
				$scope.inProgress = false;
				$scope.$apply();
			});
	}
	$scope.saveDraft = function()
	{
		$scope.inProgress = true;
		saveDraft($scope.selectedDraft)
			.then(data => {
				$scope.inProgress = false;
				$scope.$apply();
			});
	}
	$scope.publish = function()
	{
		$scope.inProgress = true;
		// We need to save-back the draft before publishing since the server publishes from the saved state.
		saveDraft($scope.selectedDraft).then(function(data) {
			// Now, begin the publish.
			REST.POST("/draft/publish/" + $scope.homePublicKey + "/" + $scope.selectedDraft.id + "/" + $scope.selectedDraft.type)
				.then(response => {
					if (response.ok)
					{
						return response.text();
					}
					else
					{
						throw new Error(response.statusText);
					}
				})
				.then(function(elementHash) {
					// Just refresh the page to point at this element.
					$scope.inProgress = false;
					$scope.$apply();
					window.location.href = "/play.html?elt=" + elementHash;
				})
				.catch(error => {
					alert("Error in publish (usually means invalid field such as a missing title): " + error.message);
					$scope.inProgress = false;
					$scope.$apply();
				});
		});
	}
	$scope.detectVideo = function()
	{
		$scope.videoState.detecting = true;
		UTILS_checkCamera(true)
			.then((resultArray) => {
				// We want to create readable elements, too.
				let resolutions = [];
				resultArray.forEach(function(elt, index, arr) {
					resolutions.push({
						width: elt.width,
						height: elt.height,
						frameRate: elt.frameRate,
						readable: (elt.width + " x " + elt.height + " @" + elt.frameRate),
					});
				});
				$scope.videoState.resolutions = resolutions;
				$scope.videoState.detecting = false;
				$scope.$apply();
			})
			.catch((err) => {
				console.log(err);
				$scope.videoState.detecting = false;
				$scope.$apply();
			});
	}
	$scope.selectResolution = function(resolution)
	{
		$scope.videoConfig.width = resolution.width;
		$scope.videoConfig.height = resolution.height;
		$scope.videoConfig.fps = resolution.frameRate;
	}
	
	// Setup related to the manual file selections.
	document.getElementById("video_upload_selector").addEventListener("change", function(event)
	{
		let file = event.srcElement.files[0];
		if (!file.type.startsWith('video/'))
		{
			// Drag and drop can bypass the "accept", it seems.
			event.srcElement.value = null;
			$scope.$apply();
		}
		else
		{
			// We need to find the meta-data.
			loadMetaData('video', file, file.type, function(file, mime, video_tag) {
				console.log("Got video: " + video_tag.videoWidth + " by " + video_tag.videoHeight);
				
				// We want to immediately upload.
				$scope.selectedFiles.uploadingVideo = true;
				uploadVideoData($scope.selectedDraft.id
					, video_tag.videoHeight
					, video_tag.videoWidth
					, mime.substring(6)
					, file
					, function(uploadedBytes, totalBytes)
					{
						let percentage = Math.round(100 * uploadedBytes / totalBytes);
						console.log("Uploading " + percentage + "%");
						video_upload_progress_bar.ariaValueNow = percentage;
						video_upload_progress_bar["style"] = "width: " + percentage + "%;";
						video_upload_progress_bar.textContent = percentage + "%";
					}
					, function(finalByteSize)
					{
						$scope.selectedDraft.originalVideo = {
							height: video_tag.videoHeight,
							width: video_tag.videoWidth,
							byteSize: finalByteSize,
						};
						document.getElementById("video_upload_selector").value = null;
						$scope.selectedFiles.uploadingVideo = false;
						$scope.$apply();
						original_review.src = "http://127.0.0.1:8000/draft/originalVideo/" + $scope.selectedDraft.id + "?uniq=" + (new Date()).getTime();
					});
			});
		}
	});
	document.getElementById("audio_upload_selector").addEventListener("change", function(event)
	{
		let file = event.srcElement.files[0];
		let mime = file.type;
		if (mime.includes('/ogg'))
		{
			// Despite the filter saying only "audio/", sometimes the browser seems to then detect "audio/ogg" and something like "video/ogg" so we will hard-code a work-around for that, here.
			mime = 'audio/ogg';
		}
		if (!mime.startsWith('audio/'))
		{
			// Drag and drop can bypass the "accept", it seems.
			event.srcElement.value = null;
			$scope.$apply();
		}
		else
		{
			// We need to find the meta-data.
			loadMetaData('audio', file, mime, function(file, mime, audio_tag) {
				console.log("Got audio");
				
				// We want to immediately upload.
				$scope.selectedFiles.uploadingAudio = true;
				uploadAudioData($scope.selectedDraft.id
					, mime.substring(6)
					, file
					, function(uploadedBytes, totalBytes)
					{
						let percentage = Math.round(100 * uploadedBytes / totalBytes);
						console.log("Uploading " + percentage + "%");
						audio_upload_progress_bar.ariaValueNow = percentage;
						audio_upload_progress_bar["style"] = "width: " + percentage + "%;";
						audio_upload_progress_bar.textContent = percentage + "%";
					}
					, function(finalByteSize)
					{
						$scope.selectedDraft.audio = {
							height: 0,
							width: 0,
							byteSize: finalByteSize,
						};
						document.getElementById("audio_upload_selector").value = null;
						$scope.selectedFiles.uploadingAudio = false;
						$scope.$apply();
						audio_review.src = "http://127.0.0.1:8000/draft/audio/" + $scope.selectedDraft.id + "?uniq=" + (new Date()).getTime();
					});
			});
		}
	});
	document.getElementById("thumbnail_upload_selector").addEventListener("change", function(event)
	{
		let file = event.srcElement.files[0];
		if (!file.type.startsWith('image/'))
		{
			// Drag and drop can bypass the "accept", it seems.
			event.srcElement.value = null;
			$scope.$apply();
		}
		else
		{
			// We need to find the meta-data.
			let img = new Image();
			img.onload = function(event)
			{
				console.log("Got thumbnail: " + img.width + " by " + img.height);
				
				// Do the immediate upload.
				$scope.selectedFiles.uploadingThumbnail = true;
				let imageType = file.type.substring(6);
				REST.POST_withBinary("/draft/thumb/" + $scope.selectedDraft.id + "/" + img.height + "/" + img.width + "/" + imageType, file)
					.then((response) => {
						$scope.selectedDraft.thumbnail = {
							height: img.height,
							width: img.width,
							byteSize: file.size,
						};
						document.getElementById("thumbnail_upload_selector").value = null;
						$scope.selectedFiles.uploadingThumbnail = false;
						$scope.selectedDraft.thumbnail.width = img.width;
						$scope.selectedDraft.thumbnail.height = img.height;
						setThumbnail(canvas, $scope.selectedDraft);
						$scope.$apply();
					});
				$scope.$apply();
			};
			img.src = URL.createObjectURL(file);
		}
	});
	$scope.setDraftType = function(type)
	{
		$scope.selectedDraft.type = type;
	}
	
	// NOTE:  We need to call this "cookie" page to set the cookie to defeat some XSRF cases (we mostly rely on SameSite to make this safe).
	API_getXsrf().then(function() {
		xsrfLoaded($scope);
	});
});

function xsrfLoaded($scope)
{
	// Start with no selection.
	$scope.homePublicKey = null;
	// We trigger the reset immediately, since we have no dependent data.
	$scope.channelSelectorResetCounter = 1;
	
	$scope.selectUserKey = function(publicKey)
	{
		$scope.homePublicKey = publicKey;
	}
	
	// We can proceed to load the other data, concurrently.
	REST.GET("/allDrafts/all")
		.then(data => data.json())
		.then(json => {
			$scope.drafts = json;
			// See if there is a replyTo parameter, since we will need to create/select a draft for that.
			let replyTo = UTILS_readGetVar("replyTo");
			if (undefined !== replyTo)
			{
				createAndSelectNewDraft($scope, replyTo);
				// Protect us from repeating this on page refresh.
				window.history.replaceState(null, "", "/publish.html");
			}
			$scope.$apply();
		});
	// Check to see if we can change the processing command (returns 403 if we can't, so we will leave it null).
	REST.GET("/server/processingCommand")
		.then((response) => {
			// We only want to continue to read the data if it is meaningful.
			if (!response.ok)
			{
				throw response.status;
			}
			return response.text();
		})
		.then(command => {
			$scope.videoConfig.mutableProcessingCommand = command;
			$scope.$apply();
		})
		// On error, just do nothing - this is just so the error doesn't appear in the logs as uncaught when this is the common case.
		.catch((errorCode) => {});
}

</script>

	<title>Cacophony - Publish or Create Draft</title>
</head>
<body ng-controller="AppController">
<nav class="navbar navbar-expand-lg navbar-dark bg-dark">
	<div class="container">
		<a class="navbar-brand" href="https://github.com/jmdisher/Cacophony">Cacophony</a>
		<ul class="navbar-nav">
			<li class="nav-item"><a class="nav-link" href="index.html">Index</a></li>
			<li class="nav-item"><a class="nav-link" href="prefs.html">Preferences</a></li>
			<li class="nav-item"><a class="nav-link" href="user.html">This User</a></li>
			<li class="nav-item"><a class="nav-link" href="recommending.html">Recommended Users</a></li>
			<li class="nav-item"><a class="nav-link" href="following.html">Users you Follow</a></li>
			<li class="nav-item"><a class="nav-link" href="favourites.html">Favourites</a></li>
			<li class="nav-item"><a class="nav-link" href="replies.html">Replies</a></li>
			<li class="nav-item"><a class="nav-link active" href="publish.html">Publish or Create Draft</a></li>
			<li class="nav-item"><a class="nav-link" href="status.html">Server Status</a></li>
		</ul>
	</div>
</nav>
<div class="container">
	<div class="row">
		<div class="card card-body col-md-3">
			<div class="row"><a class="btn" href="index.html">Index</a></div>
			<div class="row"><a class="btn" href="prefs.html">Preferences</a></div>
			<div class="row"><a class="btn" href="user.html">This User</a></div>
			<div class="row"><a class="btn" href="recommending.html">Recommended Users</a></div>
			<div class="row"><a class="btn" href="following.html">Users you Follow</a></div>
			<div class="row"><a class="btn" href="favourites.html">Favourites</a></div>
			<div class="row"><a class="btn" href="replies.html">Replies</a></div>
			<div class="row"><a class="btn" href="publish.html">Publish or Create Draft</a></div>
			<div class="row"><a class="btn" href="status.html">Server Status</a></div>
			<caco-channel-selector on-select-user="selectUserKey" reset-counter="channelSelectorResetCounter"></caco-channel-selector>
		</div>
		<div class="card card-body col-md-6" ng-show="null !== homePublicKey">
			<em ng-show="null == drafts">Loading drafts...</em>
			<div class="row" ng-show="null != drafts">Drafts ({{drafts.length}}):<br />
				<ul>
					<li ng-repeat="draft in drafts">
						<div class="btn-group">
							<button class="btn btn-sm btn-danger dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false">Delete</button>
							<ul class="dropdown-menu"><li><a class="dropdown-item" ng-click="deleteDraft(draft)">Confirm</a></li></ul>
						</div>
						<a ng-click="selectDraft(draft)" ng-show="draft.title.length > 0">{{draft.title}}</a>
						<a ng-click="selectDraft(draft)" ng-show="draft.title.length === 0">(unnamed draft {{draft.id}})</a>
					</li>
				</ul>
			</div>
		</div>
		<div class="card card-body col-md-3" ng-show="null !== homePublicKey">
			<button class="btn btn-sm btn-success" ng-click="createNewDraft()" ng-disabled="inProgress">New Draft</button><br />
		</div>
		<div class="col-md-9" ng-show="null === homePublicKey">
			<strong>No home user selected.</strong>
		</div>
	</div>
	<div class="row" ng-show="null !== homePublicKey">
		<div class="col-md-12">
			<div class="card card-body" ng-show="null == selectedDraft">
				Select a draft to see details.
			</div>
			<div class="card card-body" ng-show="null != selectedDraft">
				Draft:  <strong>{{selectedDraft.title}}</strong><br />
				<span ng-show="null !== selectedDraft.replyTo">Reply to: <caco-post-small cid="selectedDraft.replyTo"></caco-post-small></span><br />
				Post type:
				<div class="btn-group" role="group">
					<button type="button" class="btn btn-primary" ng-click="setDraftType('TEXT_ONLY')" ng-disabled="'TEXT_ONLY' === selectedDraft.type">Text only</button>
					<button type="button" class="btn btn-primary" ng-click="setDraftType('VIDEO')" ng-disabled="'VIDEO' === selectedDraft.type">Video</button>
					<button type="button" class="btn btn-primary" ng-click="setDraftType('AUDIO')" ng-disabled="'AUDIO' === selectedDraft.type">Audio</button>
				</div>
				<div class="card card-body">
					Video preview: <br />
					<button type="button" class="btn btn-primary" ng-show="null === videoState.resolutions" ng-click="detectVideo()" ng-disabled="videoState.detecting">Detect camera and resolutions</button>
					<div class="btn-group" ng-show="null !== videoState.resolutions">
						<button class="btn btn-danger dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false">Select camera resolution</button>
						<ul class="dropdown-menu">
							<li ng-repeat="resolution in videoState.resolutions"><a class="dropdown-item" ng-click="selectResolution(resolution)">{{resolution.readable}}</a></li>
						</ul>
					</div>
					Height: <input type="text" class="form-control" ng-model="videoConfig.height" ng-disabled="null != videoState.stream"></input><br />
					Width: <input type="text" class="form-control" ng-model="videoConfig.width" ng-disabled="null != videoState.stream"></input><br />
					FPS: <input type="text" class="form-control" ng-model="videoConfig.fps" ng-disabled="null != videoState.stream"></input><br />
					<video id="video_preview" ng-show="null !== videoState.stream" playsinline autoplay muted></video><br />
					<div class="btn-group" role="group">
						<button type="button" class="btn btn-primary" ng-click="startCamera()" ng-disabled="null != videoState.stream">Start Camera</button>
						<button type="button" class="btn btn-primary" ng-click="stopCamera()" ng-disabled="null == videoState.stream">Stop Camera</button>
					</div>
				</div>
				<div class="card card-body" ng-show="'VIDEO' === selectedDraft.type">
					<!-- It looks like this old version of Angular doesn't bind file inputs so we need to do this manually. -->
					<br />Upload video from filesystem: <input type="file" accept="video/*" id="video_upload_selector" ng-disabled="selectedFiles.video.uploading" />
					<div class="progress" ng-show="selectedFiles.video.uploading">
						<div class="progress-bar" id="video_upload_progress_bar" role="progressbar" aria-valuenow="50" aria-valuemin="0" aria-valuemax="100" style="width: 0%;">
							0%
						</div>
					</div>
				</div>
				<div class="card card-body" ng-show="'AUDIO' === selectedDraft.type">
					<!-- It looks like this old version of Angular doesn't bind file inputs so we need to do this manually. -->
					<br />Upload audio from filesystem: <input type="file" accept="audio/*" id="audio_upload_selector" ng-disabled="selectedFiles.audio.uploading" />
					<div class="progress" ng-show="selectedFiles.audio.uploading">
						<div class="progress-bar" id="audio_upload_progress_bar" role="progressbar" aria-valuenow="50" aria-valuemin="0" aria-valuemax="100" style="width: 0%;">
							0%
						</div>
					</div>
				</div>
				<div class="card card-body" ng-show="(null != videoState.stream) && ('VIDEO' === selectedDraft.type)">
					Recording: <br />
					Video bits/s: <input type="text" class="form-control" ng-model="videoConfig.videoBitrate" ng-disabled="null != videoState.recorder"></input><br />
					Audio bits/s: <input type="text" class="form-control" ng-model="videoConfig.audioBitrate" ng-disabled="null != videoState.recorder"></input><br />
					<button class="btn btn-success" ng-click="startRecordingVideo()" ng-disabled="null != videoState.recorder">Start Recording</button>
					<button class="btn btn-danger" ng-click="stopRecordingVideo()" ng-disabled="null == videoState.recorder">Stop Recording</button>
				</div>
				<div class="card card-body" ng-show="(null != audioState.stream) && ('AUDIO' === selectedDraft.type)">
					Recording: <br />
					Audio bits/s: <input type="text" class="form-control" ng-model="videoConfig.audioBitrate" ng-disabled="null != audioState.recorder"></input><br />
					<button class="btn btn-success" ng-click="startRecordingAudioOnly()" ng-disabled="null !== audioState.recorder">Start Recording Audio</button>
					<button class="btn btn-danger" ng-click="stopRecordingAudio()" ng-disabled="null === audioState.recorder">Stop Recording Audio</button>
				</div>
				<div class="card card-body" ng-show="(selectedDraft.originalVideo.byteSize > 0) && ('VIDEO' === selectedDraft.type)">
					<video id="original_review" controls></video><br />
					<button class="btn btn-danger" ng-click="deleteOriginalVideo(selectedDraft)" ng-disabled="inProgress">Delete</button> Original video:  {{selectedDraft.originalVideo.byteSize}} bytes.
				</div>
				<div class="card card-body"  ng-show="(selectedDraft.originalVideo.byteSize > 0) && ('VIDEO' === selectedDraft.type)">
					Post-processing: <br />
					Web browsers typically do a poor job of compressing video since they are favouring real-time framerate, as opposed to minimal size.<br />
					Since most web applications rely on a central server to do recompression, for their own storage benefits, this isn't as big a deal as it is for Cacophony (since every user hosts whatever they record, and their followers replicate it).  To allow better compression, Cacophony can invoke host-side recompression programs, if you have one installed (default is ffmpeg but you can change this with "--overrideCommand", when starting the server).<br />
					<span ng-show="null !== videoConfig.mutableProcessingCommand">Recompression command: <input type="text" class="form-control" ng-model="videoConfig.mutableProcessingCommand" ng-disabled="null !== videoState.processingSocket"></input></span><br />
					<button class="btn btn-success" ng-click="startProcessing()" ng-disabled="inProgress || (null != videoState.processingSocket)">Start Processing</button>
					<button class="btn btn-danger" ng-click="stopProcessing()" ng-disabled="inProgress || (null == videoState.processingSocket)">Stop Processing</button>
					<div class="progress" ng-show="null != videoState.processingSocket">
						<div class="progress-bar" id="processing_progress_bar" role="progressbar" aria-valuenow="50" aria-valuemin="0" aria-valuemax="100" style="width: 0%;">
							0%
						</div>
					</div>
				</div>
				<div class="card card-body" ng-show="(selectedDraft.processedVideo.byteSize > 0) && ('VIDEO' === selectedDraft.type)">
					<video id="processed_review" controls></video><br />
					<button class="btn btn-danger" ng-click="deleteProcessedVideo(selectedDraft)" ng-disabled="inProgress">Delete</button> Processed video:  {{selectedDraft.processedVideo.byteSize}} bytes.
				</div>
				<div class="card card-body" ng-show="(null !== selectedDraft.audio) && ('AUDIO' === selectedDraft.type)">
					<audio id="audio_review" controls></audio><br />
					<button class="btn btn-danger" ng-click="deleteAudio(selectedDraft)" ng-disabled="inProgress">Delete</button> Audio:  {{selectedDraft.audio.byteSize}} bytes.
				</div>
				<div class="card card-body">
					Thumbnail: <br />
					<div class="card card-body" ng-show="selectedDraft.thumbnail.byteSize > 0">
						<canvas id="canvas"></canvas><br />
						<button class="btn btn-danger" ng-click="deletethumbnail(selectedDraft)" ng-disabled="(null == selectedDraft.thumbnail) || (0 == selectedDraft.thumbnail.byteSize) || inProgress">Delete</button> Thumbnail:  {{selectedDraft.thumbnail.width}} x {{selectedDraft.thumbnail.height}} ({{selectedDraft.thumbnail.byteSize}} bytes).
					</div>
					Capture thumbnail:<br />
					<div class="btn-group" role="group">
						<button type="button" class="btn btn-primary" ng-click="captureFromPreview()" ng-disabled="null == videoState.stream">Capture from preview</button>
						<button type="button" class="btn btn-primary" ng-click="captureOriginal()" ng-disabled="(null == selectedDraft.originalVideo) || (0 == selectedDraft.originalVideo.byteSize)">Capture from original video</button>
						<button type="button" class="btn btn-primary" ng-click="captureProcessed()" ng-disabled="(null == selectedDraft.processedVideo) || (0 == selectedDraft.processedVideo.byteSize)">Capture from processed video</button>
					</div>
					
					<!-- It looks like this old version of Angular doesn't bind file inputs so we need to do this manually. -->
					<br />Upload thumbnail from filesystem: <input type="file" accept="image/*" id="thumbnail_upload_selector" ng-disabled="selectedFiles.thumbnail.uploading" />
				</div>
				<div class="card card-body">
					Title: <input type="text" class="form-control" ng-model="selectedDraft.title"></input><br />
					Description (limited to 20000 characters):<br />
					<textarea class="form-control" ng-model="selectedDraft.description" rows="12" maxlength="20000"></textarea><br />
					Discussion URL:
					<input type="text" class="form-control" placeholder="(no link)" ng-model="selectedDraft.discussionUrl"></input><br />
					<div class="btn-group" role="group">
						<button type="button" class="btn btn-success" ng-click="saveDraft()" ng-disabled="inProgress">Save Draft</button>
						<button type="button" class="btn btn-danger" ng-click="publish()" ng-show="('TEXT_ONLY' === selectedDraft.type) || ((null === selectedDraft.originalVideo) && (null === selectedDraft.processedVideo) && (null === selectedDraft.audio))" ng-disabled="inProgress || (null === homePublicKey)">Publish without video</button>
						<button type="button" class="btn btn-danger" ng-click="publish()" ng-show="(selectedDraft.originalVideo.byteSize > 0) && (null === selectedDraft.processedVideo) && ('VIDEO' === selectedDraft.type)" ng-disabled="inProgress || (null === homePublicKey)">Publish with original video</button>
						<button type="button" class="btn btn-danger" ng-click="publish()" ng-show="(selectedDraft.processedVideo.byteSize > 0) && ('VIDEO' === selectedDraft.type)" ng-disabled="inProgress || (null === homePublicKey)">Publish with processed video</button>
						<button type="button" class="btn btn-danger" ng-click="publish()" ng-show="(selectedDraft.audio.byteSize > 0) && ('AUDIO' === selectedDraft.type)" ng-disabled="inProgress || (null === homePublicKey)">Publish with audio</button>
					</div>
				</div>
			</div>
		</div>
	</div>
</div>
</body>
</html>

