<!DOCTYPE html>
<html lang="en" ng-app="App">
<head>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js" type="text/javascript"></script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.3.3/angular.min.js" type="text/javascript"></script>

<meta charset="utf-8"></meta>
<meta name="viewport" content="width=device-width, initial-scale=1"></meta>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-gH2yIJqKdNHPEq0n4Mqa/HGKIhSkIHeL5AyhkYV8i59U5AR6csBvApHHNl/vI1Bx" crossorigin="anonymous"></link>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/js/bootstrap.bundle.min.js" integrity="sha384-A3rJD856KowSb7dwlZdYEkO39Gagi7vIsF0jrRAoQmDKKtQBHUuLZ9AsSv4jD4Xa" crossorigin="anonymous"></script>

<script src="./rest.js" type="text/javascript"></script>
<script src="./generated_db.js" type="text/javascript"></script>
<script type="text/javascript">
function stopServer()
{
	REST.POST("/stop")
		.then(data => data.text())
		.then(text => console.log(text));
}

function startCamera(height, width, fps)
{
	return new Promise((resolve, reject) => {
		let constraints = { video: { width: {exact: width}, height: {exact: height}, frameRate: {exact: fps}}, audio: {channelCount: {exact: 1}}};
		navigator.mediaDevices.getUserMedia(constraints).then(resolve, reject);
	});
}

function stopCamera(previewElement, videoState)
{
	previewElement.srcObject = null;
	videoState.stream.getTracks().forEach(function(track) { track.stop(); });
	videoState.stream = null;
}

function openVideoUploadWebSocket(draftId, height, width, videoType, onOpen, onClose)
{
	let ws = new WebSocket("ws://127.0.0.1:8000/draft/saveVideo/" + draftId + "/" + height + "/" + width + "/" + videoType, "video");
	ws.onopen = onOpen;
	ws.onclose = onClose;
	ws.onerror = function(event)
	{
		console.log(event);
	};
	
	return ws;
}

function uploadVideoData(draftId, height, width, videoType, fileData, progressCallback, finalSizeCallback)
{
	let bytes = 0;
	let ws = openVideoUploadWebSocket(draftId, height, width, videoType,
	function()
	{
		let chunkSize = 64 * 1024;
		for (let start = 0; start < fileData.size; start += chunkSize)
		{
			let split = Math.min(fileData.size - start, chunkSize);
			let blob = fileData.slice(start, start + split);
			ws.send(blob);
			bytes += split;
			progressCallback(bytes, fileData.size);
		}
		ws.close();
	},
	function()
	{
		finalSizeCallback(bytes);
	});
}

function startRecording(stream, videoBitrate, audioBitrate, draftId, height, width, finalSizeCallback)
{
	let recorder = new MediaRecorder(stream, { mimeType: 'video/webm', audioBitsPerSecond: audioBitrate,  videoBitsPerSecond: videoBitrate });
	let bytes = 0;
	let ws = openVideoUploadWebSocket(draftId, height, width, 'webm',
	function()
	{
		recorder.addEventListener('dataavailable', function(e) {
			bytes += e.data.size;
			ws.send(e.data);
		});
		recorder.addEventListener('stop', function() {
			ws.close();
		});
		recorder.start(100);
	},
	function()
	{
		finalSizeCallback(bytes);
	});
	return recorder;
}

function stopRecording(videoState)
{
	videoState.recorder.stop();
	videoState.recorder = null;
}

function selectDraft(canvas, original_review, processed_review, scope, draft)
{
	scope.selectedDraft = draft;
	if (null !== draft)
	{
		if (null !== draft.thumbnail)
		{
			let image = new Image();
			image.onload = function () {
				canvas.getContext('2d').drawImage(image, 0, 0);
			};
			image.src = "http://127.0.0.1:8000/draft/thumb/" + draft.id + "?uniq=" + (new Date()).getTime();
		}
		else
		{
			canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);
		}
		if (null !== draft.originalVideo)
		{
			scope.videoConfig.height = draft.originalVideo.height;
			scope.videoConfig.width = draft.originalVideo.width;
			original_review.src = "http://127.0.0.1:8000/draft/originalVideo/" + draft.id + "?uniq=" + (new Date()).getTime();
		}
		else
		{
			scope.videoConfig.height =  720;
			scope.videoConfig.width = 1280;
			original_review.src = "";
		}
		
		if (null !== draft.processedVideo)
		{
			processed_review.src = "http://127.0.0.1:8000/draft/processedVideo/" + draft.id + "?uniq=" + (new Date()).getTime();
		}
		else
		{
			processed_review.src = "";
		}
	}
	else
	{
		original_review.src = "";
		processed_review.src = "";
	}
}

function postUpdatedThumbnail(canvas, captureVideo, selectedDraft, width, height)
{
	return new Promise((resolve, reject) => {
		canvas.getContext('2d').drawImage(captureVideo, 0, 0, width, height);
		canvas.toBlob((blob) => {
			REST.POST_withBinary("/draft/thumb/" + selectedDraft.id + "/" + height + "/" + width + "/jpeg", blob)
				.then((response) => {
					selectedDraft.thumbnail = {
						height: height,
						width: width,
						byteSize: blob.size,
					};
					resolve();
				});
		}, "image/jpeg");
	});
}

function saveDraft(selectedDraft)
{
	let variables = {
		"title": selectedDraft.title,
		"description": selectedDraft.description,
	};
	if (null != selectedDraft.discussionUrl)
	{
		variables["discussionUrl"] = selectedDraft.discussionUrl;
	}
	return REST.POST_asForm("/draft/" + selectedDraft.id, variables);
}

function waitForPublish(scope)
{
	scope.publishInProgress = true;
	REST.POST("/wait/publish")
		.then(function(data) {
			scope.publishInProgress = false;
			scope.$apply();
		});
}


// We will create an Angular controller and populate it with data from generated_db.js.
var GLOBAL_Application = angular.module('App', []);
GLOBAL_Application.controller('AppController', function($scope)
{
	let canvas = document.getElementById('canvas');
	let video_preview = document.getElementById('video_preview');
	let original_review = document.getElementById('original_review');
	let processed_review = document.getElementById('processed_review');
	let progress_bar = document.getElementById('progress_bar');
	let upload_progress_bar = document.getElementById('upload_progress_bar');
	
	$scope.drafts = null;
	$scope.selectedDraft = null;
	$scope.inProgress = false;
	$scope.publishInProgress = false;
	
	// This is set after we get the cookie - call to "GET /videoConfig".
	$scope.videoConfig = null;
	$scope.videoState = {
		stream: null,
		recorder: null,
		processingSocket: null,
		finalProcessed: 0,
	};
	
	// Data we use to with the manual file uploads.
	$scope.selectedFiles = {
		video: null,
	};
	
	$scope.stopServer = function()
	{
		// We can't call this directly since it is a module.
		stopServer();
	}
	$scope.selectDraft = function(draft)
	{
		selectDraft(canvas, original_review, processed_review, $scope, draft);
	}
	$scope.createNewDraft = function()
	{
		REST.POST("/createDraft")
			.then(data => data.json())
			.then(draftObject => {
				$scope.drafts.push(draftObject);
				$scope.selectedDraft = draftObject;
				$scope.$apply();
			});
	}
	$scope.deleteDraft = function(draft)
	{
		REST.DELETE("/draft/" + draft.id)
			.then(data => {
				if ((null !== $scope.selectedDraft) && ($scope.selectedDraft.id === draft.id))
				{
					selectDraft(canvas, original_review, processed_review, $scope, null);
				}
				$scope.drafts = $scope.drafts.filter((element, index, array) => {
					return (element.id !== draft.id);
				});
				$scope.$apply();
			});
	}
	$scope.startCamera = function()
	{
		startCamera($scope.videoConfig.height, $scope.videoConfig.width, $scope.videoConfig.fps)
			.then(result => {
				$scope.videoState.stream = result;
				video_preview.srcObject = result;
				$scope.$apply();
			}, error => {
				alert(error);
				$scope.$apply();
			});
	}
	$scope.stopCamera = function()
	{
		stopCamera(video_preview, $scope.videoState);
	}
	$scope.startRecording = function()
	{
		$scope.videoState.recorder = startRecording($scope.videoState.stream
			, $scope.videoConfig.videoBitrate
			, $scope.videoConfig.audioBitrate
			, $scope.selectedDraft.id
			, $scope.videoConfig.height
			, $scope.videoConfig.width
			, function(finalByteSize)
			{
				$scope.selectedDraft.originalVideo = {
					height: $scope.videoConfig.height,
					width: $scope.videoConfig.width,
					byteSize: finalByteSize,
				};
				$scope.$apply();
				original_review.src = "http://127.0.0.1:8000/draft/originalVideo/" + $scope.selectedDraft.id + "?uniq=" + (new Date()).getTime();
			}
		);
	}
	$scope.stopRecording = function()
	{
		stopRecording($scope.videoState);
	}
	$scope.startProcessing = function()
	{
		$scope.videoState.processingSocket = new WebSocket("ws://127.0.0.1:8000/draft/processVideo/" + $scope.selectedDraft.id + "/" + encodeURIComponent($scope.videoConfig.processingCommand), "process");
		$scope.videoState.processingSocket.onopen = function()
		{
			console.log("Process start");
		}
		$scope.videoState.processingSocket.addEventListener('message', (event) => {
			let object = JSON.parse(event.data);
			if ("progress" == object.type)
			{
				let percentage = Math.round(100 * object.bytes / $scope.selectedDraft.originalVideo.byteSize);
				console.log("Processing " + percentage + "%");
				progress_bar.ariaValueNow = percentage;
				progress_bar["style"] = "width: " + percentage + "%;";
				progress_bar.textContent = percentage + "%";
			}
			else if ("done" == object.type)
			{
				$scope.videoState.finalProcessed = object.bytes;
			}
		});
		$scope.videoState.processingSocket.onclose = function(e)
		{
			$scope.selectedDraft.processedVideo = {
				height: $scope.videoConfig.height,
				width: $scope.videoConfig.width,
				byteSize: $scope.videoState.finalProcessed,
			};
			$scope.videoState.processingSocket = null;
			$scope.videoState.finalProcessed = 0;
			$scope.$apply();
			processed_review.src = "http://127.0.0.1:8000/draft/processedVideo/" + $scope.selectedDraft.id + "?uniq=" + (new Date()).getTime();
			console.log("Process DONE");
		}
	}
	$scope.stopProcessing = function()
	{
		$scope.videoState.processingSocket.close();
	}
	$scope.captureFromPreview = function()
	{
		postUpdatedThumbnail(canvas, video_preview, $scope.selectedDraft, $scope.videoConfig.width, $scope.videoConfig.height)
			.then((response) => {
				$scope.$apply();
			});
	}
	$scope.captureOriginal = function()
	{
		postUpdatedThumbnail(canvas, original_review, $scope.selectedDraft, $scope.videoConfig.width, $scope.videoConfig.height)
			.then((response) => {
				$scope.$apply();
			});
	}
	$scope.captureProcessed = function()
	{
		postUpdatedThumbnail(canvas, processed_review, $scope.selectedDraft, $scope.videoConfig.width, $scope.videoConfig.height)
			.then((response) => {
				$scope.$apply();
			});
	}
	$scope.deleteOriginalVideo = function(draft)
	{
		$scope.inProgress = true;
		REST.DELETE("/draft/originalVideo/" + draft.id)
			.then(data => {
				draft.originalVideo = null;
				$scope.inProgress = false;
				$scope.$apply();
			});
	}
	$scope.deleteProcessedVideo = function(draft)
	{
		$scope.inProgress = true;
		REST.DELETE("/draft/processedVideo/" + draft.id)
			.then(data => {
				draft.processedVideo = null;
				$scope.inProgress = false;
				$scope.$apply();
			});
	}
	$scope.deletethumbnail = function(draft)
	{
		$scope.inProgress = true;
		REST.DELETE("/draft/thumb/" + draft.id)
			.then(data => {
				// Update UI.
				canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);
				
				// Update data model.
				draft.thumbnail = null;
				$scope.inProgress = false;
				$scope.$apply();
			});
	}
	$scope.saveDraft = function()
	{
		$scope.inProgress = true;
		saveDraft($scope.selectedDraft)
			.then(data => {
				$scope.inProgress = false;
				$scope.$apply();
			});
	}
	$scope.publish = function()
	{
		$scope.inProgress = true;
		// We need to save-back the draft before publishing since the server publishes from the saved state.
		saveDraft($scope.selectedDraft).then(function(data) {
			// Now, begin the publish.
			REST.POST("/draft/publish/" + $scope.selectedDraft.id)
				.then(function(data) {
					$scope.drafts = $scope.drafts.filter(elt => elt !== $scope.selectedDraft);
					$scope.selectedDraft = null;
					$scope.inProgress = false;
					// Request that we wait for the publish.
					waitForPublish($scope);
					$scope.$apply();
				});
		});
	}
	
	// Setup related to the manual file selections.
	document.getElementById("video_upload_selector").addEventListener("change", function(event)
	{
		let file = event.srcElement.files[0];
		if (!file.type.startsWith('video/'))
		{
			// Drag and drop can bypass the "accept", it seems.
			event.srcElement.value = null;
			$scope.selectedFiles.video = null;
			$scope.$apply();
		}
		else
		{
			// We need to find the meta-data.
			const video = document.createElement('video');
			video.addEventListener('loadedmetadata', event => {
				console.log("Got video: " + video.videoWidth + " by " + video.videoHeight);
				$scope.selectedFiles.video = {
					file: file,
					name: file.name,
					byteSize: file.size,
					mime: file.type,
					videoWidth: video.videoWidth,
					videoHeight: video.videoHeight,
				};
				$scope.$apply();
			})
			video.src = URL.createObjectURL(file);
		}
	});
	$scope.uploadSelectedVideo = function()
	{
		$scope.selectedFiles.video.uploading = true;
		uploadVideoData($scope.selectedDraft.id
			, $scope.selectedFiles.video.videoHeight
			, $scope.selectedFiles.video.videoWidth
			, $scope.selectedFiles.video.mime.substring(6)
			, $scope.selectedFiles.video.file
			, function(uploadedBytes, totalBytes)
			{
				let percentage = Math.round(100 * uploadedBytes / totalBytes);
				console.log("Uploading " + percentage + "%");
				upload_progress_bar.ariaValueNow = percentage;
				upload_progress_bar["style"] = "width: " + percentage + "%;";
				upload_progress_bar.textContent = percentage + "%";
			}
			, function(finalByteSize)
			{
				$scope.selectedDraft.originalVideo = {
					height: $scope.selectedFiles.video.videoHeight,
					width: $scope.selectedFiles.video.videoWidth,
					byteSize: finalByteSize,
				};
				document.getElementById("video_upload_selector").value = null;
				$scope.selectedFiles.video = null;
				$scope.$apply();
				original_review.src = "http://127.0.0.1:8000/draft/originalVideo/" + $scope.selectedDraft.id + "?uniq=" + (new Date()).getTime();
			});
	}
	
	// NOTE:  We need to call this "cookie" page to set the cookie to defeat some XSRF cases (we mostly rely on SameSite to make this safe).
	API_getXsrf().then(function() {
		REST.GET("/drafts")
			.then(data => data.json())
			.then(json => {
				$scope.drafts = json;
				$scope.$apply();
			});
		REST.GET("/videoConfig")
			.then(data => data.json())
			.then(json => {
				$scope.videoConfig = json;
				$scope.$apply();
			});
	});
});

</script>

	<title>Cacophony - Static Index</title>
</head>
<body ng-controller="AppController">
<nav class="navbar navbar-expand-lg navbar-dark bg-dark">
	<div class="container">
		<a class="navbar-brand" href="https://github.com/jmdisher/Cacophony">Cacophony</a>
		<ul class="navbar-nav">
			<li class="nav-item"><a class="nav-link" href="index.html">Index</a></li>
			<li class="nav-item"><a class="nav-link" href="prefs.html">Preferences</a></li>
			<li class="nav-item"><a class="nav-link" href="user.html">This User</a></li>
			<li class="nav-item"><a class="nav-link" href="recommending.html">Recommended Users</a></li>
			<li class="nav-item"><a class="nav-link" href="following.html">Users you Follow</a></li>
			<li class="nav-item"><a class="nav-link active" href="publish.html">Publish or Create Draft</a></li>
		</ul>
	</div>
</nav>
<div class="container">
	<div class="row">
		<div class="card card-body col-md-3">
			<div class="row"><a class="btn" href="index.html">Index</a></div>
			<div class="row"><a class="btn" href="prefs.html">Preferences</a></div>
			<div class="row"><a class="btn" href="user.html">This User</a></div>
			<div class="row"><a class="btn" href="recommending.html">Recommended Users</a></div>
			<div class="row"><a class="btn" href="following.html">Users you Follow</a></div>
			<div class="row"><a class="btn" href="publish.html">Publish or Create Draft</a></div>
		</div>
		<div class="card card-body col-md-6">
			<em ng-show="null == drafts">Loading drafts...</em>
			<div class="row" ng-show="null != drafts">Drafts ({{drafts.length}}):<br />
				<ul>
					<li ng-repeat="draft in drafts"><button class="btn btn-sm btn-danger" ng-click="deleteDraft(draft)">Delete</button> <a ng-click="selectDraft(draft)">{{draft.title}}</a></li>
				</ul>
			</div>
			<strong ng-show="publishInProgress">Publish in progress (this could take a while)...</strong>
		</div>
		<div class="card card-body col-md-3">
			<button class="btn btn-danger" ng-click="stopServer()">STOP SERVER</button><br/>
			<button class="btn btn-small btn-success" ng-click="createNewDraft()" ng-disabled="inProgress">New Draft</button><br />
		</div>
	</div>
	<div class="row">
		<div class="col-md-12">
			<div class="card card-body" ng-show="null == selectedDraft">
				Select a draft to see details.
			</div>
			<div class="card card-body" ng-show="null != selectedDraft">
				Draft:  <strong>{{selectedDraft.title}}</strong>.<br />
				<div class="card card-body">
					Video preview: <br />
					Height: <input type="text" class="form-control" ng-model="videoConfig.height" ng-disabled="null != videoState.stream"></input><br />
					Width: <input type="text" class="form-control" ng-model="videoConfig.width" ng-disabled="null != videoState.stream"></input><br />
					Framerate: <input type="text" class="form-control" ng-model="videoConfig.fps" ng-disabled="null != videoState.stream"></input><br />
					<video id="video_preview" playsinline autoplay muted></video><br />
					<div class="btn-group" role="group">
						<button type="button" class="btn btn-primary" ng-click="startCamera()" ng-disabled="null != videoState.stream">Start Camera</button>
						<button type="button" class="btn btn-primary" ng-click="stopCamera()" ng-disabled="null == videoState.stream">Stop Camera</button>
					</div>
					
					<!-- It looks like this old version of Angular doesn't bind file inputs so we need to do this manually. -->
					<br />Upload from filesystem: <input type="file" accept="video/*" id="video_upload_selector" />
					<button type="button" class="btn btn-primary" ng-click="uploadSelectedVideo()" ng-show="null !== selectedFiles.video" ng-disabled="selectedFiles.video.uploading">Upload {{selectedFiles.video.name}} ({{selectedFiles.video.byteSize}} bytes)</button><br />
					<div class="progress" ng-show="selectedFiles.video.uploading">
						<div class="progress-bar" id="upload_progress_bar" role="progressbar" aria-valuenow="50" aria-valuemin="0" aria-valuemax="100" style="width: 0%;">
							0%
						</div>
					</div>
				</div>
				<div class="card card-body" ng-show="null != videoState.stream">
					Recording: <br />
					Video bits/s: <input type="text" class="form-control" ng-model="videoConfig.videoBitrate" ng-disabled="null != videoState.recorder"></input><br />
					Audio bits/s: <input type="text" class="form-control" ng-model="videoConfig.audioBitrate" ng-disabled="null != videoState.recorder"></input><br />
					<button class="btn btn-success" ng-click="startRecording()" ng-disabled="null != videoState.recorder">Start Recording</button>
					<button class="btn btn-danger" ng-click="stopRecording()" ng-disabled="null == videoState.recorder">Stop Recording</button>
				</div>
				<div class="card card-body" ng-show="selectedDraft.originalVideo.byteSize > 0">
					<video id="original_review" controls></video><br />
					<button class="btn btn-danger" ng-click="deleteOriginalVideo(selectedDraft)" ng-disabled="inProgress">Delete</button> Original video:  {{selectedDraft.originalVideo.byteSize}} bytes.
				</div>
				<div class="card card-body"  ng-show="selectedDraft.originalVideo.byteSize > 0">
					Post-processing: <br />
					Web browsers typically do a poor job of compressing video since they are favouring real-time framerate, as opposed to minimal size.<br />
					Since most web applications rely on a central server to do recompression, for their own storage benefits, this isn't as big a deal as it is for Cacophony (since every user hosts whatever they record, and their followers replicate it).  To allow better compression, Cacophony can invoke host-side recompression programs, if you have one installed.<br />
					Recompression command: <input type="text" class="form-control" ng-model="videoConfig.processingCommand" ng-disabled="!videoConfig.canChangeCommand || (null != videoState.processingSocket)"></input><br />
					<button class="btn btn-success" ng-click="startProcessing()" ng-disabled="inProgress || (null != videoState.processingSocket)">Start Processing</button>
					<button class="btn btn-danger" ng-click="stopProcessing()" ng-disabled="inProgress || (null == videoState.processingSocket)">Stop Processing</button>
					<div class="progress" ng-show="null != videoState.processingSocket">
						<div class="progress-bar" id="progress_bar" role="progressbar" aria-valuenow="50" aria-valuemin="0" aria-valuemax="100" style="width: 0%;">
							0%
						</div>
					</div>
				</div>
				<div class="card card-body" ng-show="selectedDraft.processedVideo.byteSize > 0">
					<video id="processed_review" controls></video><br />
					<button class="btn btn-danger" ng-click="deleteProcessedVideo(selectedDraft)" ng-disabled="inProgress">Delete</button> Processed video:  {{selectedDraft.processedVideo.byteSize}} bytes.
				</div>
				<div class="card card-body">
					Thumbnail: <br />
					<div class="card card-body" ng-show="selectedDraft.thumbnail.byteSize > 0">
						<canvas id="canvas" width="{{videoConfig.width}}" height="{{videoConfig.height}}"></canvas><br />
						<button class="btn btn-danger" ng-click="deletethumbnail(selectedDraft)" ng-disabled="(null == selectedDraft.thumbnail) || (0 == selectedDraft.thumbnail.byteSize) || inProgress">Delete</button> Thumbnail:  {{selectedDraft.thumbnail.byteSize}} bytes.
					</div>
					Capture thumbnail:<br />
					<div class="btn-group" role="group">
						<button type="button" class="btn btn-primary" ng-click="captureFromPreview()" ng-disabled="null == videoState.stream">Capture from preview</button>
						<button type="button" class="btn btn-primary" ng-click="captureOriginal()" ng-disabled="(null == selectedDraft.originalVideo) || (0 == selectedDraft.originalVideo.byteSize)">Capture from original video</button>
						<button type="button" class="btn btn-primary" ng-click="captureProcessed()" ng-disabled="(null == selectedDraft.processedVideo) || (0 == selectedDraft.processedVideo.byteSize)">Capture from processed video</button>
					</div>
				</div>
				<div class="card card-body">
					Title: <input type="text" class="form-control" ng-model="selectedDraft.title"></input><br />
					<textarea class="form-control" ng-model="selectedDraft.description" rows="4" maxlength="2000"></textarea><br />
					Discussion URL: <button class="btn btn-primary" ng-click="selectedDraft.discussionUrl = ''" ng-show="null == selectedDraft.discussionUrl">Add Discussion URL</button>
					<input type="text" class="form-control" ng-model="selectedDraft.discussionUrl" ng-show="null != selectedDraft.discussionUrl"></input><br />
					<div class="btn-group" role="group">
						<button type="button" class="btn btn-success" ng-click="saveDraft()" ng-disabled="inProgress">Save Draft</button>
						<button type="button" class="btn btn-danger" ng-click="publish()" ng-disabled="inProgress">Publish</button>
					</div>
				</div>
			</div>
		</div>
	</div>
</div>
</body>
</html>

