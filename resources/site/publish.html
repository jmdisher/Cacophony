<!DOCTYPE html>
<html lang="en" ng-app="App">
<head>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js" type="text/javascript"></script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.3.3/angular.min.js" type="text/javascript"></script>

<meta charset="utf-8"></meta>
<meta name="viewport" content="width=device-width, initial-scale=1"></meta>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-gH2yIJqKdNHPEq0n4Mqa/HGKIhSkIHeL5AyhkYV8i59U5AR6csBvApHHNl/vI1Bx" crossorigin="anonymous"></link>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/js/bootstrap.bundle.min.js" integrity="sha384-A3rJD856KowSb7dwlZdYEkO39Gagi7vIsF0jrRAoQmDKKtQBHUuLZ9AsSv4jD4Xa" crossorigin="anonymous"></script>

<script src="./rest.js" type="text/javascript"></script>
<script src="./generated_db.js" type="text/javascript"></script>
<script src="./event_api.js" type="text/javascript"></script>
<script type="text/javascript">
function startCamera(height, width, fps)
{
	return new Promise((resolve, reject) => {
		let video = { width: {exact: width}, height: {exact: height}};
		if (null !== fps)
		{
			video.frameRate = {exact: fps};
		}
		let constraints = { video: video, audio: {channelCount: {exact: 1}}};
		navigator.mediaDevices.getUserMedia(constraints).then(resolve, reject);
	});
}

function stopCamera(previewElement, videoState, audioState)
{
	previewElement.srcObject = null;
	videoState.stream.getTracks().forEach(function(track) { track.stop(); });
	videoState.stream = null;
	audioState.stream = null;
}

function openVideoUploadWebSocket(draftId, height, width, videoType, onOpen, onClose)
{
	let ws = new WebSocket("ws://127.0.0.1:8000/draft/saveVideo/" + draftId + "/" + height + "/" + width + "/" + videoType, "video");
	ws.onopen = onOpen;
	ws.onclose = onClose;
	ws.onerror = function(event)
	{
		console.log(event);
	};
	
	return ws;
}

function openAudioUploadWebSocket(draftId, audioType, onOpen, onClose)
{
	let ws = new WebSocket("ws://127.0.0.1:8000/draft/saveAudio/" + draftId + "/" + audioType, "audio");
	ws.onopen = onOpen;
	ws.onclose = onClose;
	ws.onerror = function(event)
	{
		console.log(event);
	};
	
	return ws;
}

function uploadVideoData(draftId, height, width, videoType, fileData, progressCallback, finalSizeCallback)
{
	let bytes = 0;
	let ws = openVideoUploadWebSocket(draftId, height, width, videoType,
	function()
	{
		let chunkSize = 64 * 1024;
		for (let start = 0; start < fileData.size; start += chunkSize)
		{
			let split = Math.min(fileData.size - start, chunkSize);
			let blob = fileData.slice(start, start + split);
			ws.send(blob);
			bytes += split;
			progressCallback(bytes, fileData.size);
		}
		ws.close();
	},
	function()
	{
		finalSizeCallback(bytes);
	});
}

function uploadAudioData(draftId, audioType, fileData, progressCallback, finalSizeCallback)
{
	let bytes = 0;
	let ws = openAudioUploadWebSocket(draftId, audioType,
	function()
	{
		let chunkSize = 64 * 1024;
		for (let start = 0; start < fileData.size; start += chunkSize)
		{
			let split = Math.min(fileData.size - start, chunkSize);
			let blob = fileData.slice(start, start + split);
			ws.send(blob);
			bytes += split;
			progressCallback(bytes, fileData.size);
		}
		ws.close();
	},
	function()
	{
		finalSizeCallback(bytes);
	});
}

function startRecordingVideo(stream, videoBitrate, audioBitrate, draftId, height, width, finalSizeCallback)
{
	let recorder = new MediaRecorder(stream, { mimeType: 'video/webm', audioBitsPerSecond: audioBitrate,  videoBitsPerSecond: videoBitrate });
	let bytes = 0;
	let ws = openVideoUploadWebSocket(draftId, height, width, 'webm',
	function()
	{
		recorder.addEventListener('dataavailable', function(e) {
			bytes += e.data.size;
			ws.send(e.data);
		});
		recorder.addEventListener('stop', function() {
			ws.close();
		});
		recorder.start(100);
	},
	function()
	{
		finalSizeCallback(bytes);
	});
	return recorder;
}

function stopRecordingVideo(videoState)
{
	videoState.recorder.stop();
	videoState.recorder = null;
}

function startRecordingAudioOnly(stream, audioBitrate, draftId, finalSizeCallback)
{
	let recorder = new MediaRecorder(stream, { mimeType: 'audio/ogg', audioBitsPerSecond: audioBitrate });
	let bytes = 0;
	let ws = openAudioUploadWebSocket(draftId, 'ogg',
	function()
	{
		recorder.addEventListener('dataavailable', function(e) {
			bytes += e.data.size;
			ws.send(e.data);
		});
		recorder.addEventListener('stop', function() {
			ws.close();
		});
		recorder.start(100);
	},
	function()
	{
		finalSizeCallback(bytes);
	});
	return recorder;
}

function stopRecordingAudio(audioState)
{
	audioState.recorder.stop();
	audioState.recorder = null;
}

function setThumbnail(canvas, draft)
{
	let image = new Image();
	canvas.width = draft.thumbnail.width;
	canvas.height = draft.thumbnail.height;
	image.onload = function () {
		canvas.getContext('2d').drawImage(image, 0, 0);
	};
	image.src = "http://127.0.0.1:8000/draft/thumb/" + draft.id + "?uniq=" + (new Date()).getTime();
}

function selectDraft(canvas, original_review, processed_review, audio_review, scope, draft)
{
	scope.selectedDraft = draft;
	if (null !== draft)
	{
		if (null !== draft.thumbnail)
		{
			setThumbnail(canvas, draft);
		}
		else
		{
			canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);
		}
		if (null !== draft.originalVideo)
		{
			scope.videoConfig.height = draft.originalVideo.height;
			scope.videoConfig.width = draft.originalVideo.width;
			original_review.src = "http://127.0.0.1:8000/draft/originalVideo/" + draft.id + "?uniq=" + (new Date()).getTime();
		}
		else
		{
			original_review.src = "";
		}
		
		if (null !== draft.processedVideo)
		{
			processed_review.src = "http://127.0.0.1:8000/draft/processedVideo/" + draft.id + "?uniq=" + (new Date()).getTime();
		}
		else
		{
			processed_review.src = "";
		}
		if (null !== draft.audio)
		{
			audio_review.src = "http://127.0.0.1:8000/draft/audio/" + draft.id + "?uniq=" + (new Date()).getTime();
		}
		else
		{
			audio_review.src = "";
		}
		populateSyntheticType(scope.selectedDraft);
	}
	else
	{
		original_review.src = "";
		processed_review.src = "";
		audio_review.src = "";
	}
}

function postUpdatedThumbnail(canvas, captureVideo, selectedDraft, width, height)
{
	canvas.width = width;
	canvas.height = height;
	return new Promise((resolve, reject) => {
		canvas.getContext('2d').drawImage(captureVideo, 0, 0, width, height);
		canvas.toBlob((blob) => {
			REST.POST_withBinary("/draft/thumb/" + selectedDraft.id + "/" + height + "/" + width + "/jpeg", blob)
				.then((response) => {
					selectedDraft.thumbnail = {
						height: height,
						width: width,
						byteSize: blob.size,
					};
					setThumbnail(canvas, selectedDraft);
					resolve();
				});
		}, "image/jpeg");
	});
}

function saveDraft(selectedDraft)
{
	let variables = {
		"title": selectedDraft.title,
		"description": selectedDraft.description,
	};
	if (null != selectedDraft.discussionUrl)
	{
		variables["discussionUrl"] = selectedDraft.discussionUrl;
	}
	return REST.POST_asForm("/draft/" + selectedDraft.id, variables);
}

// The "type" field is essentially a synthetic enum (see POST_Raw_DraftPublish.PublishType):
// -VIDEO
// -TEXT_ONLY
// -AUDIO
// This method over-writes that field in the given draft by looking at the other elements to see what kind of data is present.
// This can be later over-written again since it is isn't actually part of the data model but just meant to be a convenient way of communicating what parts of the UI the user wants to see and what data it should actually publish.
function populateSyntheticType(draft)
{
	// If we have a processed video OR an original video, this can be considered a VIDEO type.
	// If there is no video, check audio.
	// Otherwise, we default to TEXT_ONLY.
	// Note that any type can have a thumbnail image.
	let type = "TEXT_ONLY";
	if ((null !== draft.originalVideo) || (null !== draft.processedVideo))
	{
		type = "VIDEO";
	}
	else if (null !== draft.audio)
	{
		type = "AUDIO";
	}
	draft.type = type;
}

function onProcessingSocketOpen(socket)
{
}

function onProcessingKeyCreate(videoState, key, value)
{
	// We will only bother with the final processed size, in this path (the input bytes will be zero on create).
	if (key === "outputBytes")
	{
		videoState.finalProcessed = value;
	}
}

function onProcessingKeyUpdate(selectedDraft, processing_progress_bar, key, value)
{
	// We only have an interest in the in-progress size, in this path (since output bytes is only ever sent in the create).
	if (key === "inputBytes")
	{
		let percentage = Math.round(100 * value / selectedDraft.originalVideo.byteSize);
		console.log("Processing " + percentage + "% " + value);
		processing_progress_bar.ariaValueNow = percentage;
		processing_progress_bar["style"] = "width: " + percentage + "%;";
		processing_progress_bar.textContent = percentage + "%";
	}
}

function onProcessingKeyDelete(key)
{
	// We don't need to track the deletion.
}

function onProcessingSocketClose(scope, processed_review, event, ignoreError)
{
	let isSuccess = (1000 === event.code);
	if (isSuccess)
	{
		scope.selectedDraft.processedVideo = {
			height: scope.videoConfig.height,
			width: scope.videoConfig.width,
			byteSize: scope.videoState.finalProcessed,
		};
		processed_review.src = "http://127.0.0.1:8000/draft/processedVideo/" + scope.selectedDraft.id + "?uniq=" + (new Date()).getTime();
	}
	scope.videoState.processingSocket = null;
	scope.videoState.finalProcessed = 0;
	scope.$apply();
	// We will allow errors, and just ignore them, in the case where this was invoked for an existing processing operation, since there might not be one.
	// Otherwise, we want to report that something odd happened.
	if (!isSuccess && !ignoreError)
	{
		alert(event.reason);
	}
}


// We will create an Angular controller and populate it with data from generated_db.js.
var GLOBAL_Application = angular.module('App', []);
GLOBAL_Application.controller('AppController', function($scope)
{
	let canvas = document.getElementById('canvas');
	let video_preview = document.getElementById('video_preview');
	let original_review = document.getElementById('original_review');
	let audio_review = document.getElementById('audio_review');
	let processed_review = document.getElementById('processed_review');
	let processing_progress_bar = document.getElementById('processing_progress_bar');
	let video_upload_progress_bar = document.getElementById('video_upload_progress_bar');
	let audio_upload_progress_bar = document.getElementById('audio_upload_progress_bar');
	
	$scope.drafts = null;
	$scope.selectedDraft = null;
	$scope.inProgress = false;
	
	// This is set after we get the cookie - call to "GET /videoConfig".
	$scope.videoConfig = null;
	$scope.videoState = {
		stream: null,
		recorder: null,
		processingSocket: null,
		finalProcessed: 0,
	};
	$scope.audioState = {
		stream: null,
		recorder: null,
		processingSocket: null,
		finalProcessed: 0,
	};
	
	// Data we use to with the manual file uploads.
	$scope.selectedFiles = {
		video: null,
		thumbnail: null,
		audio: null,
	};
	
	$scope.selectDraft = function(draft)
	{
		selectDraft(canvas, original_review, processed_review, audio_review, $scope, draft);
		// These keys are defined in VideoProcessContainer.java.
		$scope.videoState.processingSocket = EVENTS_API.existingVideo($scope.selectedDraft.id
			// onSocketOpen
			, onProcessingSocketOpen
			// onCreate
			, function(key, value) { onProcessingKeyCreate($scope.videoState, key, value); }
			// onUpdate
			, function(key, value) {onProcessingKeyUpdate($scope.selectedDraft, processing_progress_bar, key, value); }
			// onDelete
			, onProcessingKeyDelete
			// onSocketClose
			, function(event) { onProcessingSocketClose($scope, processed_review, event, true); }
		);
	}
	$scope.createNewDraft = function()
	{
		REST.POST("/createDraft")
			.then(data => data.json())
			.then(draftObject => {
				populateSyntheticType(draftObject);
				$scope.drafts.push(draftObject);
				$scope.selectedDraft = draftObject;
				$scope.$apply();
			});
	}
	$scope.deleteDraft = function(draft)
	{
		REST.DELETE("/draft/" + draft.id)
			.then(data => {
				if ((null !== $scope.selectedDraft) && ($scope.selectedDraft.id === draft.id))
				{
					selectDraft(canvas, original_review, processed_review, audio_review, $scope, null);
				}
				$scope.drafts = $scope.drafts.filter((element, index, array) => {
					return (element.id !== draft.id);
				});
				$scope.$apply();
			});
	}
	$scope.startCamera = function()
	{
		let fps = $scope.videoConfig.enableFps
			? $scope.videoConfig.fps
			: null
		;
		startCamera($scope.videoConfig.height, $scope.videoConfig.width, fps)
			.then(result => {
				$scope.videoState.stream = result;
				// We will also extract the audio track.
				$scope.audioState.stream = new MediaStream(result.getAudioTracks());
				// If the framerate was disabled, see what we got and store it in the UI.
				if (!$scope.videoConfig.enableFps)
				{
					$scope.videoConfig.fps = result.getVideoTracks()[0].getSettings().frameRate;
				}
				video_preview.srcObject = result;
				$scope.$apply();
			}, error => {
				alert(error);
				$scope.$apply();
			});
	}
	$scope.stopCamera = function()
	{
		stopCamera(video_preview, $scope.videoState, $scope.audioState);
	}
	$scope.startRecordingVideo = function()
	{
		$scope.videoState.recorder = startRecordingVideo($scope.videoState.stream
			, $scope.videoConfig.videoBitrate
			, $scope.videoConfig.audioBitrate
			, $scope.selectedDraft.id
			, $scope.videoConfig.height
			, $scope.videoConfig.width
			, function(finalByteSize)
			{
				$scope.selectedDraft.originalVideo = {
					height: $scope.videoConfig.height,
					width: $scope.videoConfig.width,
					byteSize: finalByteSize,
				};
				$scope.$apply();
				original_review.src = "http://127.0.0.1:8000/draft/originalVideo/" + $scope.selectedDraft.id + "?uniq=" + (new Date()).getTime();
			}
		);
	}
	$scope.stopRecordingVideo = function()
	{
		stopRecordingVideo($scope.videoState);
	}
	$scope.startRecordingAudioOnly = function()
	{
		$scope.audioState.recorder = startRecordingAudioOnly($scope.audioState.stream
			, $scope.videoConfig.audioBitrate
			, $scope.selectedDraft.id
			, function(finalByteSize)
			{
				$scope.selectedDraft.audio = {
					height: 0,
					width: 0,
					byteSize: finalByteSize,
				};
				$scope.$apply();
				audio_review.src = "http://127.0.0.1:8000/draft/audio/" + $scope.selectedDraft.id + "?uniq=" + (new Date()).getTime();
			}
		);
	}
	$scope.stopRecordingAudio = function()
	{
		stopRecordingAudio($scope.audioState);
	}
	$scope.startProcessing = function()
	{
		// The processing socket uses our standard events API.
		// These keys are defined in VideoProcessContainer.java.
		$scope.videoState.processingSocket = EVENTS_API.processVideo($scope.selectedDraft.id, $scope.videoConfig.processingCommand
			// onSocketOpen
			, onProcessingSocketOpen
			// onCreate
			, function(key, value) { onProcessingKeyCreate($scope.videoState, key, value); }
			// onUpdate
			, function(key, value) {onProcessingKeyUpdate($scope.selectedDraft, processing_progress_bar, key, value); }
			// onDelete
			, onProcessingKeyDelete
			// onSocketClose
			, function(event) { onProcessingSocketClose($scope, processed_review, event, false); }
		);
	}
	$scope.stopProcessing = function()
	{
		// Constant defined in VideoProcessContainer.java.
		$scope.videoState.processingSocket.send("COMMAND_CANCEL_PROCESSING");
	}
	$scope.captureFromPreview = function()
	{
		postUpdatedThumbnail(canvas, video_preview, $scope.selectedDraft, $scope.videoConfig.width, $scope.videoConfig.height)
			.then((response) => {
				$scope.$apply();
			});
	}
	$scope.captureOriginal = function()
	{
		postUpdatedThumbnail(canvas, original_review, $scope.selectedDraft, $scope.videoConfig.width, $scope.videoConfig.height)
			.then((response) => {
				$scope.$apply();
			});
	}
	$scope.captureProcessed = function()
	{
		postUpdatedThumbnail(canvas, processed_review, $scope.selectedDraft, $scope.videoConfig.width, $scope.videoConfig.height)
			.then((response) => {
				$scope.$apply();
			});
	}
	$scope.deleteOriginalVideo = function(draft)
	{
		$scope.inProgress = true;
		REST.DELETE("/draft/originalVideo/" + draft.id)
			.then(data => {
				draft.originalVideo = null;
				$scope.inProgress = false;
				$scope.$apply();
			});
	}
	$scope.deleteProcessedVideo = function(draft)
	{
		$scope.inProgress = true;
		REST.DELETE("/draft/processedVideo/" + draft.id)
			.then(data => {
				draft.processedVideo = null;
				$scope.inProgress = false;
				$scope.$apply();
			});
	}
	$scope.deleteAudio = function(draft)
	{
		$scope.inProgress = true;
		REST.DELETE("/draft/audio/" + draft.id)
			.then(data => {
				draft.audio = null;
				$scope.inProgress = false;
				$scope.$apply();
			});
	}
	$scope.deletethumbnail = function(draft)
	{
		$scope.inProgress = true;
		REST.DELETE("/draft/thumb/" + draft.id)
			.then(data => {
				// Update UI.
				canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);
				
				// Update data model.
				draft.thumbnail = null;
				$scope.inProgress = false;
				$scope.$apply();
			});
	}
	$scope.saveDraft = function()
	{
		$scope.inProgress = true;
		saveDraft($scope.selectedDraft)
			.then(data => {
				$scope.inProgress = false;
				$scope.$apply();
			});
	}
	$scope.publish = function()
	{
		$scope.inProgress = true;
		// We need to save-back the draft before publishing since the server publishes from the saved state.
		saveDraft($scope.selectedDraft).then(function(data) {
			// Now, begin the publish.
			REST.POST("/draft/publish/" + $scope.selectedDraft.id + "/" + $scope.selectedDraft.type)
				.then(function(data) {
					$scope.drafts = $scope.drafts.filter(elt => elt !== $scope.selectedDraft);
					$scope.selectedDraft = null;
					$scope.inProgress = false;
					// NOTE:  The publish operation is still continuing, but in the background (can be seen on the status page).
					$scope.$apply();
				});
		});
	}
	
	// Setup related to the manual file selections.
	document.getElementById("video_upload_selector").addEventListener("change", function(event)
	{
		let file = event.srcElement.files[0];
		if (!file.type.startsWith('video/'))
		{
			// Drag and drop can bypass the "accept", it seems.
			event.srcElement.value = null;
			$scope.selectedFiles.video = null;
			$scope.$apply();
		}
		else
		{
			// We need to find the meta-data.
			const video = document.createElement('video');
			video.addEventListener('loadedmetadata', event => {
				console.log("Got video: " + video.videoWidth + " by " + video.videoHeight);
				$scope.selectedFiles.video = {
					file: file,
					name: file.name,
					byteSize: file.size,
					mime: file.type,
					videoWidth: video.videoWidth,
					videoHeight: video.videoHeight,
				};
				$scope.$apply();
			})
			video.src = URL.createObjectURL(file);
		}
	});
	document.getElementById("audio_upload_selector").addEventListener("change", function(event)
	{
		let file = event.srcElement.files[0];
		let mime = file.type;
		if (mime.includes('/ogg'))
		{
			// Despite the filter saying only "audio/", sometimes the browser seems to then detect "audio/ogg" and something like "video/ogg" so we will hard-code a work-around for that, here.
			mime = 'audio/ogg';
		}
		if (!mime.startsWith('audio/'))
		{
			// Drag and drop can bypass the "accept", it seems.
			event.srcElement.value = null;
			$scope.selectedFiles.audio = null;
			$scope.$apply();
		}
		else
		{
			// We need to find the meta-data.
			const audio = document.createElement('audio');
			audio.addEventListener('loadedmetadata', event => {
				console.log("Got audio");
				$scope.selectedFiles.audio = {
					file: file,
					name: file.name,
					byteSize: file.size,
					mime: mime,
					videoWidth: 0,
					videoHeight: 0,
				};
				$scope.$apply();
			})
			audio.src = URL.createObjectURL(file);
		}
	});
	document.getElementById("thumbnail_upload_selector").addEventListener("change", function(event)
	{
		let file = event.srcElement.files[0];
		if (!file.type.startsWith('image/'))
		{
			// Drag and drop can bypass the "accept", it seems.
			event.srcElement.value = null;
			$scope.selectedFiles.thumbnail = null;
			$scope.$apply();
		}
		else
		{
			// We need to find the meta-data.
			let img = new Image();
			img.onload = function(event)
			{
				console.log("Got thumbnail: " + img.width + " by " + img.height);
				$scope.selectedFiles.thumbnail = {
					file: file,
					name: file.name,
					byteSize: file.size,
					mime: file.type,
					imageWidth: img.width,
					imageHeight: img.height,
				};
				$scope.$apply();
			};
			img.src = URL.createObjectURL(file);
		}
	});
	$scope.uploadSelectedVideo = function()
	{
		$scope.selectedFiles.video.uploading = true;
		uploadVideoData($scope.selectedDraft.id
			, $scope.selectedFiles.video.videoHeight
			, $scope.selectedFiles.video.videoWidth
			, $scope.selectedFiles.video.mime.substring(6)
			, $scope.selectedFiles.video.file
			, function(uploadedBytes, totalBytes)
			{
				let percentage = Math.round(100 * uploadedBytes / totalBytes);
				console.log("Uploading " + percentage + "%");
				video_upload_progress_bar.ariaValueNow = percentage;
				video_upload_progress_bar["style"] = "width: " + percentage + "%;";
				video_upload_progress_bar.textContent = percentage + "%";
			}
			, function(finalByteSize)
			{
				$scope.selectedDraft.originalVideo = {
					height: $scope.selectedFiles.video.videoHeight,
					width: $scope.selectedFiles.video.videoWidth,
					byteSize: finalByteSize,
				};
				document.getElementById("video_upload_selector").value = null;
				$scope.selectedFiles.video = null;
				$scope.$apply();
				original_review.src = "http://127.0.0.1:8000/draft/originalVideo/" + $scope.selectedDraft.id + "?uniq=" + (new Date()).getTime();
			});
	}
	$scope.uploadSelectedAudio = function()
	{
		$scope.selectedFiles.audio.uploading = true;
		uploadAudioData($scope.selectedDraft.id
			, $scope.selectedFiles.audio.mime.substring(6)
			, $scope.selectedFiles.audio.file
			, function(uploadedBytes, totalBytes)
			{
				let percentage = Math.round(100 * uploadedBytes / totalBytes);
				console.log("Uploading " + percentage + "%");
				audio_upload_progress_bar.ariaValueNow = percentage;
				audio_upload_progress_bar["style"] = "width: " + percentage + "%;";
				audio_upload_progress_bar.textContent = percentage + "%";
			}
			, function(finalByteSize)
			{
				$scope.selectedDraft.audio = {
					height: 0,
					width: 0,
					byteSize: finalByteSize,
				};
				document.getElementById("audio_upload_selector").value = null;
				$scope.selectedFiles.audio = null;
				$scope.$apply();
				audio_review.src = "http://127.0.0.1:8000/draft/audio/" + $scope.selectedDraft.id + "?uniq=" + (new Date()).getTime();
			});
	}
	$scope.uploadSelectedThumbnail = function()
	{
		$scope.selectedFiles.thumbnail.uploading = true;
		let height = $scope.selectedFiles.thumbnail.imageHeight;
		let width = $scope.selectedFiles.thumbnail.imageWidth;
		let imageType = $scope.selectedFiles.thumbnail.mime.substring(6);
		REST.POST_withBinary("/draft/thumb/" + $scope.selectedDraft.id + "/" + height + "/" + width + "/" + imageType, $scope.selectedFiles.thumbnail.file)
			.then((response) => {
				$scope.selectedDraft.thumbnail = {
					height: height,
					width: width,
					byteSize: $scope.selectedFiles.thumbnail.byteSize,
				};
				document.getElementById("thumbnail_upload_selector").value = null;
				$scope.selectedFiles.thumbnail = null;
				$scope.selectedDraft.thumbnail.width = width;
				$scope.selectedDraft.thumbnail.height = height;
				setThumbnail(canvas, $scope.selectedDraft);
				$scope.$apply();
			});
	}
	$scope.setDraftType = function(type)
	{
		$scope.selectedDraft.type = type;
	}
	$scope.setVideoConfig = function(width, height)
	{
		$scope.videoConfig.width = width;
		$scope.videoConfig.height = height;
	}
	
	// NOTE:  We need to call this "cookie" page to set the cookie to defeat some XSRF cases (we mostly rely on SameSite to make this safe).
	API_getXsrf().then(function() {
		REST.GET("/drafts")
			.then(data => data.json())
			.then(json => {
				$scope.drafts = json;
				$scope.$apply();
			});
		REST.GET("/videoConfig")
			.then(data => data.json())
			.then(json => {
				$scope.videoConfig = json;
				$scope.$apply();
			});
	});
});

</script>

	<title>Cacophony - Static Index</title>
</head>
<body ng-controller="AppController">
<nav class="navbar navbar-expand-lg navbar-dark bg-dark">
	<div class="container">
		<a class="navbar-brand" href="https://github.com/jmdisher/Cacophony">Cacophony</a>
		<ul class="navbar-nav">
			<li class="nav-item"><a class="nav-link" href="index.html">Index</a></li>
			<li class="nav-item"><a class="nav-link" href="prefs.html">Preferences</a></li>
			<li class="nav-item"><a class="nav-link" href="user.html">This User</a></li>
			<li class="nav-item"><a class="nav-link" href="recommending.html">Recommended Users</a></li>
			<li class="nav-item"><a class="nav-link" href="following.html">Users you Follow</a></li>
			<li class="nav-item"><a class="nav-link active" href="publish.html">Publish or Create Draft</a></li>
			<li class="nav-item"><a class="nav-link" href="status.html">Server Status</a></li>
		</ul>
	</div>
</nav>
<div class="container">
	<div class="row">
		<div class="card card-body col-md-3">
			<div class="row"><a class="btn" href="index.html">Index</a></div>
			<div class="row"><a class="btn" href="prefs.html">Preferences</a></div>
			<div class="row"><a class="btn" href="user.html">This User</a></div>
			<div class="row"><a class="btn" href="recommending.html">Recommended Users</a></div>
			<div class="row"><a class="btn" href="following.html">Users you Follow</a></div>
			<div class="row"><a class="btn" href="publish.html">Publish or Create Draft</a></div>
			<div class="row"><a class="btn" href="status.html">Server Status</a></div>
		</div>
		<div class="card card-body col-md-6">
			<em ng-show="null == drafts">Loading drafts...</em>
			<div class="row" ng-show="null != drafts">Drafts ({{drafts.length}}):<br />
				<ul>
					<li ng-repeat="draft in drafts"><button class="btn btn-sm btn-danger" ng-click="deleteDraft(draft)">Delete</button> <a ng-click="selectDraft(draft)">{{draft.title}}</a></li>
				</ul>
			</div>
		</div>
		<div class="card card-body col-md-3">
			<button class="btn btn-small btn-success" ng-click="createNewDraft()" ng-disabled="inProgress">New Draft</button><br />
		</div>
	</div>
	<div class="row">
		<div class="col-md-12">
			<div class="card card-body" ng-show="null == selectedDraft">
				Select a draft to see details.
			</div>
			<div class="card card-body" ng-show="null != selectedDraft">
				Draft:  <strong>{{selectedDraft.title}}</strong><br />
				Post type:
				<div class="btn-group" role="group">
					<button type="button" class="btn btn-primary" ng-click="setDraftType('TEXT_ONLY')" ng-disabled="'TEXT_ONLY' === selectedDraft.type">Text only</button>
					<button type="button" class="btn btn-primary" ng-click="setDraftType('VIDEO')" ng-disabled="'VIDEO' === selectedDraft.type">Video</button>
					<button type="button" class="btn btn-primary" ng-click="setDraftType('AUDIO')" ng-disabled="'AUDIO' === selectedDraft.type">Audio</button>
				</div>
				<div class="card card-body">
					Video preview: <br />
					<div class="btn-group btn-group-sm" role="group" aria-label="Presets">
						Common presets: 
						<button type="button" class="btn btn-light" ng-click="setVideoConfig(640, 480)" ng-disabled="null != videoState.stream">480p (4:3)</button>
						<button type="button" class="btn btn-light" ng-click="setVideoConfig(1280, 720)" ng-disabled="null != videoState.stream">720p (16:9)</button>
					</div>
					Height: <input type="text" class="form-control" ng-model="videoConfig.height" ng-disabled="null != videoState.stream"></input><br />
					Width: <input type="text" class="form-control" ng-model="videoConfig.width" ng-disabled="null != videoState.stream"></input><br />
					<div class="input-group">
						<input type="checkbox" class="btn-check" ng-model="videoConfig.enableFps" id="framecheck" autocomplete="off">
							<label class="btn btn-outline-primary" for="framecheck">Enable framerate</label>
						</input>
						<input type="text" class="form-control" placeholder="Specify framerate" ng-model="videoConfig.fps" ng-disabled="(null !== videoState.stream) || !videoConfig.enableFps"></input>
					</div>
					<video id="video_preview" ng-show="null !== videoState.stream" playsinline autoplay muted></video><br />
					<div class="btn-group" role="group">
						<button type="button" class="btn btn-primary" ng-click="startCamera()" ng-disabled="null != videoState.stream">Start Camera</button>
						<button type="button" class="btn btn-primary" ng-click="stopCamera()" ng-disabled="null == videoState.stream">Stop Camera</button>
					</div>
				</div>
				<div class="card card-body" ng-show="'VIDEO' === selectedDraft.type">
					<!-- It looks like this old version of Angular doesn't bind file inputs so we need to do this manually. -->
					<br />Upload video from filesystem: <input type="file" accept="video/*" id="video_upload_selector" />
					<button type="button" class="btn btn-primary" ng-click="uploadSelectedVideo()" ng-show="null !== selectedFiles.video" ng-disabled="selectedFiles.video.uploading">Upload {{selectedFiles.video.name}} ({{selectedFiles.video.byteSize}} bytes)</button><br />
					<div class="progress" ng-show="selectedFiles.video.uploading">
						<div class="progress-bar" id="video_upload_progress_bar" role="progressbar" aria-valuenow="50" aria-valuemin="0" aria-valuemax="100" style="width: 0%;">
							0%
						</div>
					</div>
				</div>
				<div class="card card-body" ng-show="'AUDIO' === selectedDraft.type">
					<!-- It looks like this old version of Angular doesn't bind file inputs so we need to do this manually. -->
					<br />Upload audio from filesystem: <input type="file" accept="audio/*" id="audio_upload_selector" />
					<button type="button" class="btn btn-primary" ng-click="uploadSelectedAudio()" ng-show="null !== selectedFiles.audio" ng-disabled="selectedFiles.audio.uploading">Upload {{selectedFiles.audio.name}} ({{selectedFiles.audio.byteSize}} bytes)</button><br />
					<div class="progress" ng-show="selectedFiles.audio.uploading">
						<div class="progress-bar" id="audio_upload_progress_bar" role="progressbar" aria-valuenow="50" aria-valuemin="0" aria-valuemax="100" style="width: 0%;">
							0%
						</div>
					</div>
				</div>
				<div class="card card-body" ng-show="(null != videoState.stream) && ('VIDEO' === selectedDraft.type)">
					Recording: <br />
					Video bits/s: <input type="text" class="form-control" ng-model="videoConfig.videoBitrate" ng-disabled="null != videoState.recorder"></input><br />
					Audio bits/s: <input type="text" class="form-control" ng-model="videoConfig.audioBitrate" ng-disabled="null != videoState.recorder"></input><br />
					<button class="btn btn-success" ng-click="startRecordingVideo()" ng-disabled="null != videoState.recorder">Start Recording</button>
					<button class="btn btn-danger" ng-click="stopRecordingVideo()" ng-disabled="null == videoState.recorder">Stop Recording</button>
				</div>
				<div class="card card-body" ng-show="(null != audioState.stream) && ('AUDIO' === selectedDraft.type)">
					Recording: <br />
					Audio bits/s: <input type="text" class="form-control" ng-model="videoConfig.audioBitrate" ng-disabled="null != audioState.recorder"></input><br />
					<button class="btn btn-success" ng-click="startRecordingAudioOnly()" ng-disabled="null !== audioState.recorder">Start Recording Audio</button>
					<button class="btn btn-danger" ng-click="stopRecordingAudio()" ng-disabled="null === audioState.recorder">Stop Recording Audio</button>
				</div>
				<div class="card card-body" ng-show="(selectedDraft.originalVideo.byteSize > 0) && ('VIDEO' === selectedDraft.type)">
					<video id="original_review" controls></video><br />
					<button class="btn btn-danger" ng-click="deleteOriginalVideo(selectedDraft)" ng-disabled="inProgress">Delete</button> Original video:  {{selectedDraft.originalVideo.byteSize}} bytes.
				</div>
				<div class="card card-body"  ng-show="(selectedDraft.originalVideo.byteSize > 0) && ('VIDEO' === selectedDraft.type)">
					Post-processing: <br />
					Web browsers typically do a poor job of compressing video since they are favouring real-time framerate, as opposed to minimal size.<br />
					Since most web applications rely on a central server to do recompression, for their own storage benefits, this isn't as big a deal as it is for Cacophony (since every user hosts whatever they record, and their followers replicate it).  To allow better compression, Cacophony can invoke host-side recompression programs, if you have one installed.<br />
					Recompression command: <input type="text" class="form-control" ng-model="videoConfig.processingCommand" ng-disabled="!videoConfig.canChangeCommand || (null != videoState.processingSocket)"></input><br />
					<button class="btn btn-success" ng-click="startProcessing()" ng-disabled="inProgress || (null != videoState.processingSocket)">Start Processing</button>
					<button class="btn btn-danger" ng-click="stopProcessing()" ng-disabled="inProgress || (null == videoState.processingSocket)">Stop Processing</button>
					<div class="progress" ng-show="null != videoState.processingSocket">
						<div class="progress-bar" id="processing_progress_bar" role="progressbar" aria-valuenow="50" aria-valuemin="0" aria-valuemax="100" style="width: 0%;">
							0%
						</div>
					</div>
				</div>
				<div class="card card-body" ng-show="(selectedDraft.processedVideo.byteSize > 0) && ('VIDEO' === selectedDraft.type)">
					<video id="processed_review" controls></video><br />
					<button class="btn btn-danger" ng-click="deleteProcessedVideo(selectedDraft)" ng-disabled="inProgress">Delete</button> Processed video:  {{selectedDraft.processedVideo.byteSize}} bytes.
				</div>
				<div class="card card-body" ng-show="(null !== selectedDraft.audio) && ('AUDIO' === selectedDraft.type)">
					<audio id="audio_review" controls></audio><br />
					<button class="btn btn-danger" ng-click="deleteAudio(selectedDraft)" ng-disabled="inProgress">Delete</button> Audio:  {{selectedDraft.audio.byteSize}} bytes.
				</div>
				<div class="card card-body">
					Thumbnail: <br />
					<div class="card card-body" ng-show="selectedDraft.thumbnail.byteSize > 0">
						<canvas id="canvas"></canvas><br />
						<button class="btn btn-danger" ng-click="deletethumbnail(selectedDraft)" ng-disabled="(null == selectedDraft.thumbnail) || (0 == selectedDraft.thumbnail.byteSize) || inProgress">Delete</button> Thumbnail:  {{selectedDraft.thumbnail.width}} x {{selectedDraft.thumbnail.height}} ({{selectedDraft.thumbnail.byteSize}} bytes).
					</div>
					Capture thumbnail:<br />
					<div class="btn-group" role="group">
						<button type="button" class="btn btn-primary" ng-click="captureFromPreview()" ng-disabled="null == videoState.stream">Capture from preview</button>
						<button type="button" class="btn btn-primary" ng-click="captureOriginal()" ng-disabled="(null == selectedDraft.originalVideo) || (0 == selectedDraft.originalVideo.byteSize)">Capture from original video</button>
						<button type="button" class="btn btn-primary" ng-click="captureProcessed()" ng-disabled="(null == selectedDraft.processedVideo) || (0 == selectedDraft.processedVideo.byteSize)">Capture from processed video</button>
					</div>
					
					<!-- It looks like this old version of Angular doesn't bind file inputs so we need to do this manually. -->
					<br />Upload thumbnail from filesystem: <input type="file" accept="image/*" id="thumbnail_upload_selector" />
					<button type="button" class="btn btn-primary" ng-click="uploadSelectedThumbnail()" ng-show="null !== selectedFiles.thumbnail" ng-disabled="selectedFiles.thumbnail.uploading">Upload {{selectedFiles.thumbnail.name}} ({{selectedFiles.thumbnail.byteSize}} bytes)</button><br />
				</div>
				<div class="card card-body">
					Title: <input type="text" class="form-control" ng-model="selectedDraft.title"></input><br />
					Description (limited to 20000 characters):<br />
					<textarea class="form-control" ng-model="selectedDraft.description" rows="12" maxlength="20000"></textarea><br />
					Discussion URL: <button class="btn btn-primary" ng-click="selectedDraft.discussionUrl = ''" ng-show="null == selectedDraft.discussionUrl">Add Discussion URL</button>
					<input type="text" class="form-control" ng-model="selectedDraft.discussionUrl" ng-show="null != selectedDraft.discussionUrl"></input><br />
					<div class="btn-group" role="group">
						<button type="button" class="btn btn-success" ng-click="saveDraft()" ng-disabled="inProgress">Save Draft</button>
						<button type="button" class="btn btn-danger" ng-click="publish()" ng-show="('TEXT_ONLY' === selectedDraft.type) || ((null === selectedDraft.originalVideo) && (null === selectedDraft.processedVideo) && (null === selectedDraft.audio))" ng-disabled="inProgress">Publish without video</button>
						<button type="button" class="btn btn-danger" ng-click="publish()" ng-show="(selectedDraft.originalVideo.byteSize > 0) && (null === selectedDraft.processedVideo) && ('VIDEO' === selectedDraft.type)" ng-disabled="inProgress">Publish with original video</button>
						<button type="button" class="btn btn-danger" ng-click="publish()" ng-show="(selectedDraft.processedVideo.byteSize > 0) && ('VIDEO' === selectedDraft.type)" ng-disabled="inProgress">Publish with processed video</button>
						<button type="button" class="btn btn-danger" ng-click="publish()" ng-show="(selectedDraft.audio.byteSize > 0) && ('AUDIO' === selectedDraft.type)" ng-disabled="inProgress">Publish with audio</button>
					</div>
				</div>
			</div>
		</div>
	</div>
</div>
</body>
</html>

